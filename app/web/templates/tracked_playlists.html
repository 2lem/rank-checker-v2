<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tracked Playlists</title>
    <link rel="stylesheet" href="/static/ui.css?v={{ build_id }}" />
    <link rel="stylesheet" href="/static/tracked.css?v={{ build_id }}" />
  </head>
  <body class="app-body">
    <main class="page" data-tracked-playlists-page>
      <header class="page-header" id="playlist-controls">
        <div>
          <h1>Tracked Playlists</h1>
          <p class="page-subtitle">Monitor playlists and manage their tracking configuration.</p>
        </div>
        <div class="page-header-actions">
          {% set label = 'Add New Playlist' %}
          {% set button_variant = 'primary' %}
          {% set type = 'button' %}
          {% set aria_controls = 'add-playlist' %}
          {% set data_target = 'add-playlist' %}
          {% include "_components/button.html" %}
          <button
            class="btn btn-secondary manual-scan-toggle"
            type="button"
            id="manual-scan-toggle"
            aria-controls="manual-scan-section"
            aria-expanded="false"
          >
            Manual Scan
          </button>
        </div>
      </header>

      <section class="ui-card status-card">
        <div class="status-card-header">
          <h2>Status</h2>
          <p class="status-card-subtitle">Use this space for feedback messages.</p>
        </div>
        <div id="playlist-status" class="status-area" role="status" aria-live="polite">
          Ready to add a playlist.
        </div>
      </section>

      <section class="ui-card manual-scan-section" id="manual-scan-section" aria-hidden="true">
        <div class="manual-scan-panel">
          <div class="panel-header">
            <h2>Manual Scan Panel</h2>
            <p>Run a manual scan using a custom playlist and targets.</p>
          </div>
          <div class="panel-body">
            <div class="basic-scan" data-manual-scan>
              <section class="scan-parameters" id="manual-scan-parameters" data-manual-scan-parameters>
                <label class="field">
                  <span class="field-label">Playlist URL</span>
                  <input
                    name="manual_playlist_url"
                    type="url"
                    placeholder="https://open.spotify.com/playlist/..."
                    data-manual-scan-playlist
                  />
                </label>
                <div class="scan-config-row">
                  <span class="scan-config-label">Countries</span>
                  <div class="field-inline">
                    <select class="market-select" data-manual-scan-country-select></select>
                    <button class="btn btn-secondary" type="button" data-manual-scan-country-add>Add</button>
                  </div>
                  <div class="pill-list" data-manual-scan-country-pills></div>
                  <div class="info-box" data-manual-scan-country-info hidden>
                    You have reached the maximum of 10 target countries.
                  </div>
                </div>
                <div class="scan-config-row">
                  <span class="scan-config-label">Keywords</span>
                  <div class="field-inline">
                    <textarea
                      name="manual_target_keywords_input"
                      rows="2"
                      placeholder="e.g. lofi, focus, chill"
                      data-manual-scan-keyword-input
                    ></textarea>
                    <button class="btn btn-secondary" type="button" data-manual-scan-keyword-add>Add</button>
                  </div>
                  <div class="pill-list" data-manual-scan-keyword-pills></div>
                  <div class="info-box" data-manual-scan-keyword-info hidden>
                    You have reached the maximum of 10 target keywords.
                  </div>
                </div>
                <div class="run-scan-controls" id="manual-run-scan-controls" data-manual-scan-run-controls>
                  <div class="manual-scan-actions">
                    <button class="btn btn-primary" type="button" data-manual-scan-run>Run Manual Scan</button>
                    <span class="manual-scan-actions-spacer" aria-hidden="true"></span>
                    <button class="btn btn-secondary" type="button" data-manual-scan-close>Close</button>
                  </div>
                </div>
              </section>
              <section
                class="run-progress basic-scan-progress"
                id="manual-scan-progress"
                data-manual-scan-progress
                hidden
              >
                <div class="progress-bar">
                  <div class="progress-fill" data-manual-scan-progress-fill></div>
                </div>
                <div class="progress-status" data-manual-scan-progress-status>Starting scan…</div>
                <div class="progress-log" data-manual-scan-progress-log></div>
              </section>
              <section class="results" id="manual-scan-results" data-manual-scan-results hidden>
                <div class="results-header">
                  <h3>Basic Scan Results</h3>
                  <div
                    class="download-csv-controls basic-scan-download-actions"
                    id="manual-scan-csv-controls"
                    data-manual-scan-csv-controls
                  >
                    <a class="btn btn-csv" data-manual-scan-export-summary>Download Summary CSV</a>
                    <a class="btn btn-csv" data-manual-scan-export-detailed>Download Detailed CSV</a>
                  </div>
                </div>
                <div class="summary" id="manual-scan-summary">
                  <h3>Summary</h3>
                  <div class="summary-lead" data-manual-scan-summary-lead></div>
                  <div class="summary-list" data-manual-scan-summary-list></div>
                </div>
                <div class="detailed-scan-insights" id="manual-scan-detailed">
                  <h3>Detailed Scan Insights</h3>
                  <div class="detailed-insights" data-manual-scan-detailed></div>
                </div>
              </section>
            </div>
          </div>
        </div>
      </section>

      <section class="ui-card form-card collapsible-card" id="add-playlist" data-collapsible="add-playlist">
        <div class="section-header">
          <h2>Add New Playlist</h2>
          <p class="section-subtitle">Paste a Spotify playlist URL and optional targeting details.</p>
        </div>
        <form id="add-playlist-form" class="form-grid" data-form="add-playlist">
          <label class="field">
            <span class="field-label">Playlist URL</span>
            <input
              name="playlist_url"
              type="url"
              placeholder="https://open.spotify.com/playlist/..."
              required
              data-playlist-input
            />
          </label>
          <label class="field">
            <span class="field-label">Target Countries</span>
            <div class="field-inline">
              <select name="target_countries_select" class="market-select" data-country-select></select>
              <button class="btn btn-secondary" type="button" data-country-add>Add</button>
            </div>
            <div class="pill-list market-pill-list" data-country-pills></div>
            <div class="info-box" data-country-info hidden>
              You have reached the maximum of 5 target countries.
            </div>
            <span class="field-help">Select up to 5 countries from Spotify markets.</span>
          </label>
          <label class="field">
            <span class="field-label">Target Keywords</span>
            <div class="field-inline">
              <textarea
                name="target_keywords_input"
                rows="2"
                placeholder="e.g. lofi, focus, chill"
                data-keyword-input
              ></textarea>
              <button class="btn btn-secondary" type="button" data-keyword-add>Add</button>
            </div>
            <div class="pill-list" data-keyword-pills></div>
            <div class="info-box" data-keyword-info hidden>
              You have reached the maximum of 5 target keywords.
            </div>
            <span class="field-help">Add up to 5 keywords to scan for.</span>
          </label>
          <div class="warning-box">
            Saved countries and keywords cannot be removed later. Please review before saving.
          </div>
          <div class="form-actions">
            {% set label = 'Save Configuration' %}
            {% set button_variant = 'primary' %}
            {% set type = 'submit' %}
            {% set extra_class = 'full-width' %}
            {% include "_components/button.html" %}
            {% set label = 'Cancel' %}
            {% set button_variant = 'secondary' %}
            {% set type = 'button' %}
            {% set extra_class = 'full-width' %}
            {% set data_target = 'add-playlist-cancel' %}
            {% include "_components/button.html" %}
          </div>
        </form>
      </section>

      <section class="tracked-section">
        <div class="section-header">
          <h2>Tracked Playlists</h2>
          <p class="section-subtitle">Click Manage to view details for a playlist.</p>
        </div>
        <div class="tracked-card-list">
          {% if playlists %}
            {% for playlist in playlists %}
              {% set variant = 'list' %}
              {% include "_components/tracked_card.html" %}
            {% endfor %}
          {% else %}
            <div class="empty-state">
              <h3>No tracked playlists yet</h3>
              <p>Add one above to begin collecting results.</p>
            </div>
          {% endif %}
        </div>
      </section>
    </main>

    <script type="module">
      import { parseKeywords } from '/static/keyword_utils.js';
      const initTrackedPlaylistsPage = () => {
        const pageRoots = document.querySelectorAll('[data-tracked-playlists-page]');
        if (pageRoots.length !== 1) {
          return;
        }
        const pageRoot = pageRoots[0];
        if (!pageRoot) {
          return;
        }
        window.__UI_DEBUG__ = true;
        const UI_DEBUG = window.__UI_DEBUG__ === true;
        const uiDebug = (...args) => {
          if (UI_DEBUG && typeof console !== 'undefined' && console.debug) {
            console.debug('[ui]', ...args);
          }
        };

        const form = document.getElementById('add-playlist-form');
        const statusArea = document.getElementById('playlist-status');
        const addPanel = document.querySelector('[data-collapsible="add-playlist"]');
        const addButton = document.querySelector('[data-panel-target="add-playlist"]');
        const addCancelButton = document.querySelector('[data-panel-target="add-playlist-cancel"]');
        const manualScanToggle = document.getElementById('manual-scan-toggle');
        const manualScanSection = document.getElementById('manual-scan-section');
        const playlistControls = document.getElementById('playlist-controls');
        const manualScanCloseButton = manualScanSection?.querySelector('[data-manual-scan-close]');

        const availableMarkets = {{ available_markets | tojson }};
        const marketLabelMap = new Map(
          availableMarkets.map((market) => [market.code.toUpperCase(), market.label])
        );

        const resolveMarketLabel = (code) => marketLabelMap.get((code || '').toUpperCase()) || code;
        const formatTimestamp = (value) => {
          if (!value) {
            return '—';
          }
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return value;
          }
          return new Intl.DateTimeFormat('sv-SE', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          }).format(date);
        };

      const formatSummaryDateParts = (value) => {
        if (!value) {
          return { dateLabel: '—', timeLabel: '—' };
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return { dateLabel: value, timeLabel: value };
        }
        const dateLabel = date.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        });
        const timeLabel = date.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
        });
        return { dateLabel, timeLabel };
      };

      const formatFileTimestamp = (value) => {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        const pad = (part) => String(part).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${day}-${month}-${year}_${hours}-${minutes}`;
      };

      const formatFollowersValue = (value) => {
        if (value === undefined || value === null || value === '') {
          return '—';
        }
        if (typeof value === 'object') {
          if ('total' in value) {
            return formatFollowersValue(value.total);
          }
          return '—';
        }
        const numeric = Number(value);
        if (Number.isFinite(numeric)) {
          return numeric.toLocaleString();
        }
        return value;
      };

      const flagEmoji = (code) => {
        const upper = (code || '').toUpperCase();
        if (upper.length !== 2) {
          return '';
        }
        return upper.replace(/./g, (char) => String.fromCodePoint(127397 + char.charCodeAt()));
      };

      const setStatus = (message, variant) => {
        if (!statusArea) {
          return;
        }
        statusArea.textContent = message;
        statusArea.classList.remove('status-success', 'status-error', 'status-loading');
        if (variant) {
          statusArea.classList.add(variant);
        }
      };

      const readErrorPayload = async (response) => {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          try {
            return await response.json();
          } catch (error) {
            return null;
          }
        }
        try {
          const text = await response.text();
          return text || null;
        } catch (error) {
          return null;
        }
      };

      const parseJsonSafely = async (response) => {
        try {
          return await response.json();
        } catch (error) {
          return null;
        }
      };

      const normalizeErrorMessage = (payload, fallback) => {
        if (!payload) {
          return fallback;
        }
        if (typeof payload === 'string') {
          return payload;
        }
        const detail = payload.detail ?? payload.message ?? payload.error ?? payload;
        if (typeof detail === 'string') {
          return detail;
        }
        try {
          return JSON.stringify(detail);
        } catch (error) {
          return fallback;
        }
      };

      const showSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = false;
        section.style.removeProperty('display');
      };

      const hideSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = true;
        section.style.display = 'none';
      };

      const scrollSectionToCenter = (section) => {
        if (!section) {
          return;
        }
        const rect = section.getBoundingClientRect();
        const sectionTop = window.scrollY + rect.top;
        const target =
          sectionTop - window.innerHeight / 2 + rect.height / 2;
        window.scrollTo({ top: Math.max(target, 0), behavior: 'smooth' });
      };

      const addKeywordsFromInput = (raw, manager) => {
        const value = raw || '';
        if (!value.trim()) {
          return false;
        }
        const keywords = parseKeywords(value);
        let addedAny = false;
        keywords.forEach((keyword) => {
          if (manager.addValue(keyword)) {
            addedAny = true;
          }
        });
        return addedAny;
      };

      const createChip = ({ label, removable, locked, onRemove }) => {
        const chip = document.createElement('span');
        chip.className = `chip ${locked ? 'chip-locked' : ''}`;
        const text = document.createElement('span');
        text.className = 'chip-label';
        text.textContent = label;
        chip.appendChild(text);
        if (removable) {
          const remove = document.createElement('button');
          remove.type = 'button';
          remove.className = 'chip-remove';
          remove.textContent = '×';
          remove.addEventListener('click', onRemove);
          chip.appendChild(remove);
        }
        return chip;
      };

      const createSelectionManager = ({
        listElement,
        infoElement,
        max,
        lockedValues = [],
        normalize,
        compare,
        getLabel,
      }) => {
        let values = [...lockedValues];

        const render = () => {
          listElement.innerHTML = '';
          values.forEach((value) => {
            const isLocked = lockedValues.some((locked) => compare(locked, value));
            const removable = !isLocked;
            listElement.appendChild(
              createChip({
                label: getLabel ? getLabel(value) : value,
                locked: isLocked,
                removable,
                onRemove: () => {
                  if (isLocked) {
                    return;
                  }
                  values = values.filter((entry) => !compare(entry, value));
                  render();
                },
              })
            );
          });
          infoElement.hidden = values.length < max;
        };

        const addValue = (raw) => {
          const value = normalize(raw);
          if (!value) {
            return false;
          }
          if (values.some((entry) => compare(entry, value))) {
            return false;
          }
          if (values.length >= max) {
            infoElement.hidden = false;
            return false;
          }
          values = [...values, value];
          render();
          return true;
        };

        const setValues = (nextValues) => {
          values = [...nextValues];
          render();
        };

        const getValues = () => [...values];

        const reset = () => {
          values = [...lockedValues];
          render();
        };

        render();

        return {
          addValue,
          getValues,
          reset,
          setValues,
        };
      };

      const setupAddPanel = () => {
        try {
          if (!addPanel || !form || !statusArea) {
            return;
          }
          const playlistInput = form.querySelector('[data-playlist-input]');
          const submitButton = form.querySelector('button[type="submit"]');
          const countrySelect = form.querySelector('[data-country-select]');
          const countryAdd = form.querySelector('[data-country-add]');
          const countryPills = form.querySelector('[data-country-pills]');
          const countryInfo = form.querySelector('[data-country-info]');
          const keywordInput = form.querySelector('[data-keyword-input]');
          const keywordAdd = form.querySelector('[data-keyword-add]');
          const keywordPills = form.querySelector('[data-keyword-pills]');
          const keywordInfo = form.querySelector('[data-keyword-info]');
          if (!playlistInput || !countrySelect || !countryPills || !countryInfo || !keywordPills || !keywordInfo) {
            return;
          }

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Select a country';
        defaultOption.disabled = true;
        defaultOption.selected = true;
        countrySelect.appendChild(defaultOption);

        availableMarkets.forEach((market) => {
          const option = document.createElement('option');
          option.value = market.code;
          option.textContent = market.label;
          countrySelect.appendChild(option);
        });

        const countryManager = createSelectionManager({
          listElement: countryPills,
          infoElement: countryInfo,
          max: 5,
          lockedValues: [],
          normalize: (value) => (value || '').trim().toUpperCase(),
          compare: (a, b) => a.toUpperCase() === b.toUpperCase(),
          getLabel: resolveMarketLabel,
        });

        const keywordManager = createSelectionManager({
          listElement: keywordPills,
          infoElement: keywordInfo,
          max: 5,
          lockedValues: [],
          normalize: (value) => (value || '').trim(),
          compare: (a, b) => a.toLowerCase() === b.toLowerCase(),
        });

        countryAdd?.addEventListener('click', () => {
          if (countryManager.addValue(countrySelect.value)) {
            countryInfo.hidden = countryManager.getValues().length < 5;
          }
        });

          if (keywordInput && keywordAdd) {
            keywordAdd.addEventListener('click', () => {
              if (addKeywordsFromInput(keywordInput.value, keywordManager)) {
                keywordInput.value = '';
              }
            });

            keywordInput.addEventListener('keydown', (event) => {
              if (event.key === 'Enter') {
                event.preventDefault();
                keywordAdd.click();
              }
            });
          }

        playlistInput?.addEventListener('input', (event) => {
          const input = event.target;
          if (input.value.includes('?')) {
            input.value = input.value.split('?')[0];
          }
        });

        form.addEventListener('reset', () => {
          countryManager.reset();
          keywordManager.reset();
        });

        addCancelButton?.addEventListener('click', () => {
          form.reset();
          addPanel.classList.remove('is-open');
        });

          form.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (submitButton) {
              submitButton.disabled = true;
            }
            const payload = {
              playlist_url: playlistInput?.value,
              target_countries: countryManager.getValues(),
              target_keywords: keywordManager.getValues(),
            };

            setStatus('Adding playlist...', 'status-loading');
            uiDebug('add-playlist:start', payload);

            let didReload = false;

            try {
              const response = await fetch('/api/playlists', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
              });

              uiDebug('add-playlist:response', response.status);

              if (!response.ok) {
                const data = await readErrorPayload(response);
                const message = normalizeErrorMessage(data, 'Unable to add playlist.');
                setStatus(message, 'status-error');
                uiDebug('add-playlist:error', message);
                return;
              }

              setStatus('Playlist added successfully. Reloading...', 'status-success');
              uiDebug('add-playlist:completed');
              addPanel.classList.remove('is-open');
              didReload = true;
              window.location.reload();
            } catch (error) {
              if (typeof console !== 'undefined' && console.error) {
                console.error('[ui] add playlist failed', error);
              }
              const message = normalizeErrorMessage(error, 'Network error while adding playlist.');
              setStatus(message, 'status-error');
              uiDebug('add-playlist:error', message);
            } finally {
              if (!didReload && statusArea?.classList.contains('status-loading')) {
                setStatus('Unable to add playlist.', 'status-error');
              }
              if (submitButton) {
                submitButton.disabled = false;
              }
            }
          });
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[ui] add panel init failed', error);
          }
        }
      };

      let currentlyOpenId = null;
      let preOpenScrollY = null;

      const clampScrollTarget = (target) => {
        const documentHeight = Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight
        );
        const maxScroll = Math.max(0, documentHeight - window.innerHeight);
        return Math.min(Math.max(0, target), maxScroll);
      };

      const scrollToCentered = (element) => {
        if (!element) {
          return;
        }
        const rect = element.getBoundingClientRect();
        const target =
          window.scrollY + rect.top - (window.innerHeight / 2 - rect.height / 2);
        window.scrollTo({ top: clampScrollTarget(target), behavior: 'smooth' });
      };

      const scrollToManualScanPanel = (panel) => {
        if (!panel) {
          return;
        }
        const padding = 16;
        const headerOffset = 0;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            const rect = panel.getBoundingClientRect();
            const panelHeight = rect.height;
            const viewportHeight = window.innerHeight;
            const currentTop = window.scrollY + rect.top;
            const targetY =
              panelHeight <= viewportHeight
                ? currentTop - Math.max(padding, (viewportHeight - panelHeight) / 2) - headerOffset
                : currentTop - padding - headerOffset;
            window.scrollTo({ top: clampScrollTarget(targetY), behavior: 'smooth' });
          });
        });
      };

      const restorePreOpenScroll = () => {
        if (preOpenScrollY === null) {
          return;
        }
        window.scrollTo({ top: clampScrollTarget(preOpenScrollY), behavior: 'smooth' });
        preOpenScrollY = null;
      };

      const setupManagePanels = () => {
        try {
          const cards = document.querySelectorAll('[data-tracked-card]');
          cards.forEach((card) => {
          const manageToggle = card.querySelector('[data-manage-toggle]');
          const managePanel = card.querySelector('[data-manage-panel]');
          const manageClose = card.querySelector('[data-manage-close]');
          const editToggle = card.querySelector('[data-edit-toggle]');
          const editPanel = card.querySelector('[data-edit-panel]');
          const editForm = card.querySelector('[data-edit-form]');
          const editCancel = card.querySelector('[data-edit-cancel]');
          const editCountrySelect = card.querySelector('[data-edit-country-select]');
          const editCountryAdd = card.querySelector('[data-edit-country-add]');
          const editCountryPills = card.querySelector('[data-edit-country-pills]');
          const editCountryInfo = card.querySelector('[data-edit-country-info]');
          const editKeywordInput = card.querySelector('[data-edit-keyword-input]');
          const editKeywordAdd = card.querySelector('[data-edit-keyword-add]');
          const editKeywordPills = card.querySelector('[data-edit-keyword-pills]');
          const editKeywordInfo = card.querySelector('[data-edit-keyword-info]');
          if (!managePanel || !editPanel || !editCountrySelect || !editCountryPills || !editCountryInfo || !editKeywordPills || !editKeywordInfo) {
            return;
          }
          const playlistId = card.dataset.playlistId;

          const existingCountries = JSON.parse(card.dataset.targetCountries || '[]');
          const existingKeywords = JSON.parse(card.dataset.targetKeywords || '[]');

          const defaultEditOption = document.createElement('option');
          defaultEditOption.value = '';
          defaultEditOption.textContent = 'Select a country';
          defaultEditOption.disabled = true;
          defaultEditOption.selected = true;
          editCountrySelect.appendChild(defaultEditOption);

          availableMarkets.forEach((market) => {
            const option = document.createElement('option');
            option.value = market.code;
            option.textContent = market.label;
            editCountrySelect.appendChild(option);
          });

          const editCountryManager = createSelectionManager({
            listElement: editCountryPills,
            infoElement: editCountryInfo,
            max: 5,
            lockedValues: existingCountries.map((value) => value.toUpperCase()),
            normalize: (value) => (value || '').trim().toUpperCase(),
            compare: (a, b) => a.toUpperCase() === b.toUpperCase(),
            getLabel: resolveMarketLabel,
          });

          const editKeywordManager = createSelectionManager({
            listElement: editKeywordPills,
            infoElement: editKeywordInfo,
            max: 5,
            lockedValues: existingKeywords,
            normalize: (value) => (value || '').trim(),
            compare: (a, b) => a.toLowerCase() === b.toLowerCase(),
          });

          const closePanels = ({ restoreScroll }) => {
            managePanel.classList.remove('is-open');
            editPanel.classList.remove('is-open');
            manageToggle?.setAttribute('aria-expanded', 'false');
            manageToggle?.classList.remove('is-active');
            if (restoreScroll) {
              restorePreOpenScroll();
              currentlyOpenId = null;
            }
          };

          const openPanels = () => {
            if (currentlyOpenId && currentlyOpenId !== playlistId) {
              const openCard = document.querySelector(
                `[data-tracked-card][data-playlist-id="${currentlyOpenId}"]`
              );
              if (openCard) {
                const openManagePanel = openCard.querySelector('[data-manage-panel]');
                const openEditPanel = openCard.querySelector('[data-edit-panel]');
                const openManageToggle = openCard.querySelector('[data-manage-toggle]');
                openManagePanel?.classList.remove('is-open');
                openEditPanel?.classList.remove('is-open');
                openManageToggle?.setAttribute('aria-expanded', 'false');
                openManageToggle?.classList.remove('is-active');
              }
            }
            if (currentlyOpenId === null) {
              preOpenScrollY = window.scrollY;
            }
            currentlyOpenId = playlistId;
            managePanel.classList.add('is-open');
            manageToggle?.setAttribute('aria-expanded', 'true');
            manageToggle?.classList.add('is-active');
            scrollToCentered(managePanel);
          };

          manageToggle?.addEventListener('click', () => {
            const isOpen = managePanel.classList.contains('is-open');
            if (isOpen) {
              closePanels({ restoreScroll: true });
            } else {
              openPanels();
            }
          });

          manageClose?.addEventListener('click', () => {
            closePanels({ restoreScroll: true });
          });

          editToggle?.addEventListener('click', () => {
            const isOpen = editPanel.classList.toggle('is-open');
            if (isOpen) {
              scrollToCentered(editPanel);
            }
          });

          editCountryAdd?.addEventListener('click', () => {
            editCountryManager.addValue(editCountrySelect.value);
          });

            if (editKeywordInput && editKeywordAdd) {
              editKeywordAdd.addEventListener('click', () => {
                if (addKeywordsFromInput(editKeywordInput.value, editKeywordManager)) {
                  editKeywordInput.value = '';
                }
              });

              editKeywordInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                  event.preventDefault();
                  editKeywordAdd.click();
                }
              });
            }

          editCancel?.addEventListener('click', () => {
            editCountryManager.setValues(existingCountries.map((value) => value.toUpperCase()));
            editKeywordManager.setValues(existingKeywords);
            editPanel.classList.remove('is-open');
          });

          editForm?.addEventListener('submit', async (event) => {
            event.preventDefault();
            const targetCountries = editCountryManager.getValues();
            const targetKeywords = editKeywordManager.getValues();

            setStatus('Saving configuration...', 'status-loading');

            try {
              const response = await fetch(`/api/playlists/${playlistId}/targets`, {
                method: 'PATCH',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  target_countries: targetCountries,
                  target_keywords: targetKeywords,
                }),
              });

              if (!response.ok) {
                const data = await parseJsonSafely(response);
                const detail = data?.detail || 'Unable to update playlist.';
                const message = typeof detail === 'string' ? detail : detail.message || JSON.stringify(detail);
                setStatus(message, 'status-error');
                return;
              }

              setStatus('Configuration saved. Reloading...', 'status-success');
              editPanel.classList.remove('is-open');
              window.location.reload();
            } catch (error) {
              setStatus('Network error while updating playlist.', 'status-error');
            }
          });

          });
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[ui] manage panel init failed', error);
          }
        }
      };

      addButton?.addEventListener('click', () => {
        if (!addPanel) {
          return;
        }
        const isOpen = addPanel.classList.toggle('is-open');
        if (isOpen) {
          scrollToCentered(addPanel);
        }
      });

      window.__SSE_RESILIENCE_ENABLED__ = window.__SSE_RESILIENCE_ENABLED__ ?? true;
      const DEBUG_SSE_RESILIENCE = window.__DEBUG_SSE_RESILIENCE__ === true;

        const setupManualScanSection = () => {
          if (!manualScanToggle || !manualScanSection) {
            return;
          }
          const scanRoot = manualScanSection.querySelector('[data-manual-scan]');
          if (!scanRoot) {
            return;
          }

          const playlistInput = scanRoot.querySelector('[data-manual-scan-playlist]');
          const countrySelect = scanRoot.querySelector('[data-manual-scan-country-select]');
          const countryAdd = scanRoot.querySelector('[data-manual-scan-country-add]');
          const countryPills = scanRoot.querySelector('[data-manual-scan-country-pills]');
          const countryInfo = scanRoot.querySelector('[data-manual-scan-country-info]');
          const keywordInput = scanRoot.querySelector('[data-manual-scan-keyword-input]');
          const keywordAdd = scanRoot.querySelector('[data-manual-scan-keyword-add]');
          const keywordPills = scanRoot.querySelector('[data-manual-scan-keyword-pills]');
          const keywordInfo = scanRoot.querySelector('[data-manual-scan-keyword-info]');

          const scanParameters = scanRoot.querySelector('[data-manual-scan-parameters]');
          const runControls = scanRoot.querySelector('[data-manual-scan-run-controls]');
          const runButton = scanRoot.querySelector('[data-manual-scan-run]');
          const progressWrap = scanRoot.querySelector('[data-manual-scan-progress]');
          const progressFill = scanRoot.querySelector('[data-manual-scan-progress-fill]');
          const progressStatus = scanRoot.querySelector('[data-manual-scan-progress-status]');
          const progressLog = scanRoot.querySelector('[data-manual-scan-progress-log]');
          const resultsWrap = scanRoot.querySelector('[data-manual-scan-results]');
          const summaryLead = scanRoot.querySelector('[data-manual-scan-summary-lead]');
          const summaryList = scanRoot.querySelector('[data-manual-scan-summary-list]');
          const detailedWrap = scanRoot.querySelector('[data-manual-scan-detailed]');
          const csvControls = scanRoot.querySelector('[data-manual-scan-csv-controls]');
          const summarySection = document.getElementById('manual-scan-summary');
          const detailedSection = document.getElementById('manual-scan-detailed');
          const exportSummary = scanRoot.querySelector('[data-manual-scan-export-summary]');
          const exportDetailed = scanRoot.querySelector('[data-manual-scan-export-detailed]');
          const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

          if (
            !playlistInput ||
            !countrySelect ||
            !countryPills ||
            !countryInfo ||
            !keywordInput ||
            !keywordPills ||
            !keywordInfo ||
            !scanParameters ||
            !runControls ||
            !runButton ||
            !progressWrap ||
            !progressFill ||
            !progressStatus ||
            !progressLog ||
            !resultsWrap ||
            !summaryLead ||
            !summaryList ||
            !detailedWrap ||
            !csvControls ||
            !summarySection ||
            !detailedSection ||
            !exportSummary ||
            !exportDetailed
          ) {
            return;
          }

        let currentStage = 1;
        let activeScanId = null;
        let eventSource = null;
        let lastProgressSignature = null;
        let pollTimer = null;
        let pollStartAt = null;
        let inactivityTimer = null;
        let reconnectTimer = null;
        let reconnectAttempts = 0;
        let pollActiveScanId = null;
        let pollInFlight = false;
        let pollFailureCount = 0;
        let pollDelayMs = 5000;
        let watchdogTimer = null;
        let lastMessageAt = null;
        let resilientEnabled = window.__SSE_RESILIENCE_ENABLED__ !== false;
        let hasStopped = false;
        let terminalState = null;
        let connectionWarningActive = false;
        let lastProgressMessage = '';
        const WATCHDOG_MS = 45000;
        const WATCHDOG_CHECK_MS = 5000;
        const POLL_BASE_DELAY_MS = 5000;
        const POLL_MAX_DELAY_MS = 30000;
        const POLL_FAILURE_WARNING_THRESHOLD = 2;

        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Select a country';
        defaultOption.disabled = true;
        defaultOption.selected = true;
        countrySelect?.appendChild(defaultOption);

        availableMarkets.forEach((market) => {
          const option = document.createElement('option');
          option.value = market.code;
          option.textContent = market.label;
          countrySelect?.appendChild(option);
        });

        const countryManager = createSelectionManager({
          listElement: countryPills,
          infoElement: countryInfo,
          max: 10,
          lockedValues: [],
          normalize: (value) => (value || '').trim().toUpperCase(),
          compare: (a, b) => a.toUpperCase() === b.toUpperCase(),
          getLabel: resolveMarketLabel,
        });

        const keywordManager = createSelectionManager({
          listElement: keywordPills,
          infoElement: keywordInfo,
          max: 10,
          lockedValues: [],
          normalize: (value) => (value || '').trim(),
          compare: (a, b) => a.toLowerCase() === b.toLowerCase(),
        });

        countryAdd?.addEventListener('click', () => {
          countryManager.addValue(countrySelect.value);
        });

        if (keywordInput && keywordAdd) {
          keywordAdd.addEventListener('click', () => {
            if (addKeywordsFromInput(keywordInput.value, keywordManager)) {
              keywordInput.value = '';
            }
          });

          keywordInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              keywordAdd.click();
            }
          });
        }

        playlistInput?.addEventListener('input', (event) => {
          const input = event.target;
          if (input.value.includes('?')) {
            input.value = input.value.split('?')[0];
          }
        });

        const setStage = (stage, scrollTarget) => {
          currentStage = stage;
          const showStage1 = stage === 1;
          const showStage2 = stage === 2;
          const showStage3 = stage === 3;

          if (showStage1) {
            showSection(scanParameters);
            showSection(runControls);
            hideSection(progressWrap);
            hideSection(resultsWrap);
            hideSection(csvControls);
          }

          if (showStage2) {
            hideSection(scanParameters);
            hideSection(runControls);
            showSection(progressWrap);
            hideSection(resultsWrap);
            hideSection(csvControls);
          }

          if (showStage3) {
            hideSection(scanParameters);
            hideSection(runControls);
            hideSection(progressWrap);
            showSection(resultsWrap);
            showSection(csvControls);
          }

          const target =
            scrollTarget ||
            (showStage1 ? scanParameters || scanRoot : showStage2 ? progressWrap : summarySection);
          scrollSectionToCenter(target);
        };

        const setProgress = (current, total, message) => {
          if (!progressWrap) {
            return;
          }
          const percent = total ? Math.min((current / total) * 100, 100) : 0;
          if (progressFill) {
            progressFill.style.width = `${percent}%`;
          }
          if (progressStatus) {
            const nextMessage = message || 'Scanning...';
            lastProgressMessage = nextMessage;
            if (!connectionWarningActive) {
              progressStatus.textContent = nextMessage;
            }
          }
        };

        const setProgressStatus = (message) => {
          if (progressStatus && message && !connectionWarningActive) {
            progressStatus.textContent = message;
            lastProgressMessage = message;
          }
        };

        const appendLog = (message) => {
          if (!progressLog || !message) {
            return;
          }
          const entry = document.createElement('div');
          entry.className = 'progress-log-entry';
          entry.textContent = message;
          progressLog.appendChild(entry);
          while (progressLog.children.length > 10) {
            progressLog.removeChild(progressLog.firstChild);
          }
          progressLog.scrollTop = progressLog.scrollHeight;
        };

        const resetProgress = () => {
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          lastProgressSignature = null;
          if (summaryList) {
            summaryList.innerHTML = '';
          }
          if (detailedWrap) {
            detailedWrap.innerHTML = '';
          }
          if (summaryLead) {
            summaryLead.textContent = '';
            summaryLead.hidden = false;
          }
          if (summaryList) {
            summaryList.hidden = false;
          }
          if (detailedSection) {
            detailedSection.hidden = false;
          }
        };

        const resolveFollowers = (result) => {
          const nestedFollowers =
            result.followers && typeof result.followers === 'object'
              ? result.followers.total
              : undefined;
          const nestedPlaylistFollowers =
            result.playlist && typeof result.playlist === 'object'
              ? result.playlist.followers || result.playlist.followers_total || result.playlist.follower_count
              : undefined;
          const nestedPlaylistFollowersTotal =
            nestedPlaylistFollowers && typeof nestedPlaylistFollowers === 'object'
              ? nestedPlaylistFollowers.total
              : undefined;
          const candidate =
            result.playlist_followers ??
            result.followers_total ??
            result.followers_count ??
            result.follower_count ??
            nestedFollowers ??
            nestedPlaylistFollowersTotal ??
            nestedPlaylistFollowers ??
            result.followers;
          return formatFollowersValue(candidate);
        };

        const renderSummary = (scan) => {
          if (!summaryLead || !summaryList) {
            return;
          }
          const hasPlaylist = Boolean(
            scan.manual_playlist?.playlist_url ||
              scan.manual_playlist?.playlist_name ||
              scan.tracked_playlist_name
          );
          summaryList.innerHTML = '';
          summaryLead.hidden = false;
          summaryList.hidden = false;
          if (!hasPlaylist) {
            summaryLead.textContent = 'Manual scan completed without a playlist.';
          }
          const follower = scan.follower_snapshot ?? '—';
          if (hasPlaylist) {
            summaryLead.textContent = `At ${formatTimestamp(
              scan.started_at
            )}, your playlist follower count was ${follower}.`;
          }
          (scan.summary || []).forEach((item) => {
            const row = document.createElement('div');
            row.className = `summary-row ${item.tracked_found_in_top20 ? '' : 'summary-row-missing'}`;
            const countryLabel = resolveMarketLabel(item.country);
            const { dateLabel, timeLabel } = formatSummaryDateParts(item.searched_at);
            const rankText = hasPlaylist
              ? item.tracked_found_in_top20
                ? `your playlist rank was #${item.tracked_rank}.`
                : 'your playlist was not found in the top 20.'
              : 'top 20 results listed.';
            row.textContent = `On ${dateLabel} at ${timeLabel} in ${countryLabel} for ‘${item.keyword}’, ${rankText}`;
            summaryList.appendChild(row);
          });
        };

        const renderDetailed = (scan) => {
          if (!detailedWrap) {
            return;
          }
          detailedWrap.innerHTML = '';
          const detailed = scan.detailed || {};
          const countryAccordions = [];
          Object.values(detailed).forEach((countryData) => {
            const countryCode = countryData.country;
            const countryDetails = document.createElement('details');
            countryDetails.className = 'accordion';
            const summary = document.createElement('summary');
            summary.textContent = `${flagEmoji(countryCode)} ${resolveMarketLabel(countryCode)}`;
            countryDetails.addEventListener('toggle', () => {
              if (!countryDetails.open) {
                return;
              }
              countryAccordions.forEach((openDetails) => {
                if (openDetails !== countryDetails) {
                  openDetails.open = false;
                }
              });
              requestAnimationFrame(() => {
                scrollSectionToCenter(countryDetails);
              });
            });
            countryDetails.appendChild(summary);
            countryAccordions.push(countryDetails);

            const keywordContainer = document.createElement('div');
            keywordContainer.className = 'accordion-body';
            const keywordAccordions = [];

            Object.entries(countryData.keywords || {}).forEach(([keyword, keywordData]) => {
              const keywordDetails = document.createElement('details');
              keywordDetails.className = 'accordion nested';
              const keywordSummary = document.createElement('summary');
              keywordSummary.textContent = `${keyword} · ${formatTimestamp(keywordData.searched_at)}`;
              keywordDetails.appendChild(keywordSummary);
              keywordDetails.addEventListener('toggle', () => {
                if (!keywordDetails.open) {
                  return;
                }
                keywordAccordions.forEach((openKeyword) => {
                  if (openKeyword !== keywordDetails) {
                    openKeyword.open = false;
                  }
                });
                requestAnimationFrame(() => {
                  scrollSectionToCenter(keywordDetails);
                });
              });

              const table = document.createElement('table');
              table.className = 'results-table';
              table.innerHTML = `
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Playlist</th>
                    <th>Owner</th>
                    <th>Followers</th>
                    <th>Songs</th>
                  </tr>
                </thead>
                <tbody></tbody>
              `;
              const tbody = table.querySelector('tbody');
              (keywordData.results || []).forEach((result) => {
                const followersValue = resolveFollowers(result);
                const row = document.createElement('tr');
                if (result.is_tracked_playlist) {
                  row.classList.add('tracked-highlight');
                }
                row.innerHTML = `
                  <td>${result.rank ?? '—'}</td>
                  <td>
                    ${
                      result.playlist_url
                        ? `<a href="${result.playlist_url}" target="_blank" rel="noopener noreferrer">${result.playlist_name || '—'}</a>`
                        : result.playlist_name || '—'
                    }
                  </td>
                  <td>${result.playlist_owner || '—'}</td>
                  <td>${followersValue}</td>
                  <td>${result.songs_count ?? '—'}</td>
                `;
                tbody.appendChild(row);
              });

              const tableScroll = document.createElement('div');
              tableScroll.className = 'table-scroll';
              tableScroll.appendChild(table);

              const keywordBody = document.createElement('div');
              keywordBody.className = 'accordion-body';
              keywordBody.appendChild(tableScroll);
              keywordDetails.appendChild(keywordBody);
              keywordContainer.appendChild(keywordDetails);
              keywordAccordions.push(keywordDetails);
            });

            countryDetails.appendChild(keywordContainer);
            detailedWrap.appendChild(countryDetails);
          });
        };

      const loadResults = async (scanId) => {
          const response = await fetch(`/api/basic-rank-checker/scans/${scanId}`);
          const data = await parseJsonSafely(response);
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load scan results.'));
          }
          if (!data || typeof data !== 'object') {
            throw new Error('Failed to load scan results.');
          }
          renderSummary(data);
          renderDetailed(data);
          if (!hasResults(data)) {
            if (summaryLead) {
              summaryLead.hidden = false;
              summaryLead.textContent = 'No results found.';
            }
            if (summaryList) {
              summaryList.hidden = true;
            }
            if (detailedSection) {
              detailedSection.hidden = true;
            }
          } else if (detailedSection) {
            detailedSection.hidden = false;
          }
          const startedAt =
            data.started_at || data.searched_at || data.summary?.[0]?.searched_at;
          const timestamp = formatFileTimestamp(startedAt);
          const effectiveScanId = data.scan_id || scanId;
          const filenameBase = timestamp
            ? `${timestamp}_${effectiveScanId}`
            : `${effectiveScanId}`;
          const buildExportUrl = (path) => {
            const url = new URL(path, window.location.origin);
            if (timeZone) {
              url.searchParams.set('timezone', timeZone);
            }
            return `${url.pathname}${url.search}`;
          };
          if (exportSummary) {
            exportSummary.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/summary.csv`
            );
            exportSummary.download = `${filenameBase}_summary.csv`;
          }
          if (exportDetailed) {
            exportDetailed.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/detailed.csv`
            );
            exportDetailed.download = `${filenameBase}_detailed.csv`;
          }
        };

        const debugLog = (...args) => {
          if (DEBUG_SSE_RESILIENCE) {
            console.debug('[manual-scan:sse]', ...args);
          }
        };

        let isCompleted = false;

        const hasResults = (scan) => {
          if (!scan || typeof scan !== 'object') {
            return false;
          }
          if (Array.isArray(scan.summary)) {
            return scan.summary.length > 0;
          }
          if (scan.detailed && typeof scan.detailed === 'object') {
            return Object.keys(scan.detailed).length > 0;
          }
          return false;
        };

        const isScanComplete = (scan) =>
          scan?.status === 'completed' || scan?.status === 'completed_partial';

        const showConnectionWarning = (message) => {
          if (!progressStatus || !activeScanId || terminalState) {
            return;
          }
          connectionWarningActive = true;
          progressStatus.textContent = message;
        };

        const clearConnectionWarning = () => {
          if (!progressStatus || !connectionWarningActive) {
            return;
          }
          connectionWarningActive = false;
          if (lastProgressMessage) {
            progressStatus.textContent = lastProgressMessage;
          }
        };

        const setTerminalState = (state) => {
          terminalState = state;
          isCompleted = state === 'completed';
        };

        const stopPolling = () => {
          if (pollTimer) {
            clearTimeout(pollTimer);
            pollTimer = null;
          }
          pollStartAt = null;
          pollActiveScanId = null;
          pollInFlight = false;
          pollFailureCount = 0;
          pollDelayMs = POLL_BASE_DELAY_MS;
          clearConnectionWarning();
        };

        const updatePollDelay = () => {
          if (pollFailureCount === 0) {
            pollDelayMs = POLL_BASE_DELAY_MS;
            return;
          }
          pollDelayMs = Math.min(
            POLL_BASE_DELAY_MS * 2 ** (pollFailureCount - 1),
            POLL_MAX_DELAY_MS
          );
        };

        const schedulePoll = () => {
          if (!pollActiveScanId || terminalState) {
            return;
          }
          if (pollTimer) {
            clearTimeout(pollTimer);
          }
          pollTimer = setTimeout(() => startCompletionPoll(pollActiveScanId), pollDelayMs);
        };

        const startCompletionPoll = async (scanId) => {
          if (!resilientEnabled || !scanId) {
            return;
          }
          if (pollInFlight) {
            return;
          }
          if (!pollActiveScanId) {
            pollActiveScanId = scanId;
            pollStartAt = Date.now();
          }
          if (Date.now() - pollStartAt > 10 * 60 * 1000) {
            debugLog('Polling timed out');
            stopPolling();
            return;
          }
          pollInFlight = true;
          try {
            const response = await fetch(
              `/api/basic-rank-checker/scans/${pollActiveScanId}`
            );
            const data = await parseJsonSafely(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Unable to check scan status.'));
            }
            pollFailureCount = 0;
            updatePollDelay();
            clearConnectionWarning();
            if (isScanComplete(data)) {
              setTerminalState('completed');
              stopEventSource();
              stopPolling();
              setProgress(1, 1, 'Scan completed.');
              await loadResults(pollActiveScanId);
              setStage(3, summarySection);
              if (runButton) {
                runButton.disabled = false;
              }
              return;
            }
            if (data.status === 'failed') {
              setTerminalState('failed');
              stopEventSource();
              stopPolling();
              appendLog('Scan failed.');
              setProgress(0, 1, 'Scan failed.');
              setStage(1);
              if (runButton) {
                runButton.disabled = false;
              }
              return;
            }
          } catch (error) {
            pollFailureCount += 1;
            updatePollDelay();
            if (pollFailureCount >= POLL_FAILURE_WARNING_THRESHOLD) {
              showConnectionWarning('Connection lost. Retrying…');
            }
            debugLog('Polling error', error);
          } finally {
            pollInFlight = false;
            if (!terminalState && pollActiveScanId) {
              schedulePoll();
            }
          }
        };

        const clearResilientTimers = () => {
          if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
          }
          if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
          }
          reconnectAttempts = 0;
        };

        const clearWatchdog = () => {
          if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
          }
          lastMessageAt = null;
        };

        const startWatchdog = () => {
          clearWatchdog();
          lastMessageAt = Date.now();
          watchdogTimer = setInterval(() => {
            if (!lastMessageAt) {
              return;
            }
            if (Date.now() - lastMessageAt > WATCHDOG_MS) {
              safeStop('timeout');
            }
          }, WATCHDOG_CHECK_MS);
        };

        const updateLastMessageAt = () => {
          lastMessageAt = Date.now();
        };

        const stopEventSource = () => {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          clearResilientTimers();
        };

        const safeStop = (reason, options = {}) => {
          if (hasStopped) {
            return false;
          }
          if (terminalState && reason === 'connection error') {
            return false;
          }
          hasStopped = true;
          const statusMessages = {
            completed: '✅ Manual scan completed.',
            timeout: 'Manual scan timed out. Please try again.',
            'connection error': 'Manual scan connection lost. Please try again.',
            'handler error': 'Manual scan failed. Please try again.',
            'scan failed': 'Manual scan failed. Please try again.',
          };
          const statusMessage = statusMessages[reason] || 'Manual scan stopped.';
          const variant = reason === 'completed' ? 'status-success' : 'status-error';
          if (reason === 'completed') {
            setTerminalState('completed');
          } else if (reason !== 'connection error') {
            setTerminalState('failed');
          }
          clearConnectionWarning();

          if (reason === 'completed') {
            setProgress(options.total || 1, options.total || 1, 'Scan completed.');
            if (!options.keepStage) {
              setStage(3, summarySection);
            }
          } else {
            setProgress(0, 1, statusMessage);
            setStage(1, scanParameters || scanRoot);
          }

          stopEventSource();
          stopPolling();
          clearWatchdog();

          if (runButton) {
            runButton.disabled = false;
          }
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          setStatus(statusMessage, variant);
          return false;
        };

        const startResilientSSE = ({ url, onMessage, onError, onOpen, onStatus, onMaxRetries }) => {
          stopEventSource();
          let closed = false;
          let lastEventAt = Date.now();
          const maxInactivityMs = 8000;
          const maxRetries = 3;
          const baseDelay = 1000;

          const scheduleInactivityCheck = () => {
            if (!resilientEnabled || closed) {
              return;
            }
            if (inactivityTimer) {
              clearTimeout(inactivityTimer);
            }
            inactivityTimer = setTimeout(() => {
              const inactiveFor = Date.now() - lastEventAt;
              if (inactiveFor >= maxInactivityMs && !closed) {
                debugLog('Inactivity detected', inactiveFor);
                onStatus?.('Connection delayed, reconnecting…');
                reconnect();
              }
            }, maxInactivityMs);
          };

          const connect = () => {
            if (closed) {
              return;
            }
            debugLog('Opening EventSource', url);
            eventSource = new EventSource(url);
            onOpen?.();
            eventSource.onmessage = (event) => {
              lastEventAt = Date.now();
              reconnectAttempts = 0;
              scheduleInactivityCheck();
              onMessage?.(event);
            };
            eventSource.onerror = (error) => {
              lastEventAt = Date.now();
              debugLog('EventSource error', error);
              const shouldReconnect = onError?.(error);
              if (shouldReconnect === false) {
                closed = true;
                stopEventSource();
                return;
              }
              reconnect();
            };
            scheduleInactivityCheck();
          };

          const reconnect = () => {
            if (closed || !resilientEnabled) {
              return;
            }
            stopEventSource();
            if (reconnectAttempts >= maxRetries) {
              closed = true;
              onStatus?.('Connection lost. Checking scan status…');
              onMaxRetries?.();
              return;
            }
            const delay = baseDelay * 2 ** reconnectAttempts;
            reconnectAttempts += 1;
            debugLog('Reconnecting in', delay);
            onStatus?.('Connection delayed, reconnecting…');
            reconnectTimer = setTimeout(connect, delay);
          };

          connect();

          return {
            close: () => {
              closed = true;
              stopEventSource();
            },
          };
        };

        const startManualScan = async () => {
          if (!runButton || !playlistInput) {
            return;
          }
          const playlistUrl = (playlistInput.value || '').trim();
          const manualCountries = countryManager.getValues();
          const manualKeywords = keywordManager.getValues();
          if (manualCountries.length === 0) {
            setStatus('Please add at least one target country.', 'status-error');
            setStage(1, scanParameters || scanRoot);
            return;
          }
          if (manualKeywords.length === 0) {
            setStatus('Please add at least one target keyword.', 'status-error');
            setStage(1, scanParameters || scanRoot);
            return;
          }

          isCompleted = false;
          hasStopped = false;
          terminalState = null;
          connectionWarningActive = false;
          lastProgressMessage = '';
          pollFailureCount = 0;
          pollDelayMs = POLL_BASE_DELAY_MS;
          runButton.disabled = true;
          resetProgress();
          setProgress(0, 0, 'Starting scan…');
          setStage(2, progressWrap || scanRoot);
          uiDebug('manual-scan:start', { playlistUrl });
          stopPolling();
          stopEventSource();
          clearWatchdog();

          let startedScan = false;

          try {
            const response = await fetch('/api/scans/manual', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                playlist_url: playlistUrl || null,
                target_keywords: manualKeywords,
                target_countries: manualCountries,
              }),
            });
            const data = await parseJsonSafely(response);
            uiDebug('manual-scan:response', response.status);
            if (!response.ok) {
              const message = Array.isArray(data?.detail)
                ? 'Please check your manual scan inputs and try again.'
                : normalizeErrorMessage(data, 'Failed to start scan.');
              throw new Error(message);
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to start scan.');
            }
            activeScanId = data.scan_id;
            startedScan = true;
            const eventsUrl = `/api/basic-rank-checker/scans/${activeScanId}/events`;
            startCompletionPoll(activeScanId);
            const handleMessage = async (event) => {
              try {
                updateLastMessageAt();
                clearConnectionWarning();
                const rawText = event?.data ?? '';
                let payload = null;
                try {
                  payload = JSON.parse(rawText);
                } catch (error) {
                  payload = null;
                }
                const statusValue = `${payload?.status ?? payload?.type ?? ''}`.toLowerCase();
                const completionText = rawText.toLowerCase();
                const completionSignals = ['completed', 'done', 'finished'];
                if (
                  completionSignals.includes(statusValue) ||
                  completionSignals.some((signal) => completionText.includes(signal))
                ) {
                  stopPolling();
                  await loadResults(activeScanId);
                  setStage(3, summarySection);
                  safeStop('completed', {
                    total: payload?.total,
                    keepStage: true,
                  });
                  uiDebug('manual-scan:completed', activeScanId);
                  return;
                }
                if (payload.type === 'progress') {
                  const signature = `${payload.step}|${payload.total}|${payload.message}`;
                  if (signature === lastProgressSignature) {
                    return;
                  }
                  lastProgressSignature = signature;
                  setProgress(payload.step, payload.total, payload.message);
                  appendLog(payload.message);
                }
                if (payload.type === 'done') {
                  // Guard against reconnect/status updates after a terminal completion.
                  stopPolling();
                  await loadResults(activeScanId);
                  setStage(3, summarySection);
                  safeStop('completed', {
                    total: payload?.total,
                    keepStage: true,
                  });
                  uiDebug('manual-scan:completed', activeScanId);
                }
                if (payload.type === 'error' || payload.type === 'failed') {
                  stopPolling();
                  appendLog(payload.message || 'Scan failed.');
                  safeStop('scan failed');
                  uiDebug('manual-scan:error', payload.message || 'Scan failed.');
                }
                if (payload.type === 'cancelled') {
                  stopPolling();
                  appendLog(payload.message || 'Scan cancelled.');
                  safeStop('scan failed');
                  uiDebug('manual-scan:cancelled', payload.message || 'Scan cancelled.');
                }
              } catch (error) {
                if (typeof console !== 'undefined' && console.error) {
                  console.error('[ui] manual scan event failed', error);
                }
                safeStop('handler error');
              }
            };

            if (resilientEnabled) {
              startResilientSSE({
                url: eventsUrl,
                onMessage: handleMessage,
                onOpen: () => startWatchdog(),
                onStatus: (status) => {
                  if (!terminalState) {
                    showConnectionWarning(status);
                  }
                },
                onError: (error) => {
                  if (typeof console !== 'undefined' && console.error) {
                    console.error('[ui] manual scan connection error', error);
                  }
                  if (!activeScanId || terminalState) {
                    return false;
                  }
                  showConnectionWarning('Connection lost. Retrying…');
                  return true;
                },
                onMaxRetries: () => {
                  if (!terminalState) {
                    startCompletionPoll(activeScanId);
                  }
                },
              });
            } else {
              eventSource = new EventSource(eventsUrl);
              startWatchdog();
              eventSource.onmessage = handleMessage;
              eventSource.onerror = (error) => {
                if (typeof console !== 'undefined' && console.error) {
                  console.error('[ui] manual scan connection error', error);
                }
                if (!activeScanId || terminalState) {
                  return;
                }
                showConnectionWarning('Connection lost. Retrying…');
                startCompletionPoll(activeScanId);
              };
            }
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[ui] manual scan start failed', error);
            }
            setStage(1);
            runButton.disabled = false;
            const message = normalizeErrorMessage(error, 'Failed to start scan.');
            setStatus(message, 'status-error');
            uiDebug('manual-scan:error', message);
          } finally {
            if (!startedScan && runButton.disabled) {
              runButton.disabled = false;
              if (currentStage === 2) {
                setStage(1);
              }
            }
            if (!startedScan) {
              stopEventSource();
              stopPolling();
              clearWatchdog();
            }
          }
        };

        const openManualScan = () => {
          if (manualScanSection.classList.contains('is-open')) {
            return;
          }
          manualScanSection.classList.add('is-open');
          manualScanToggle.classList.add('is-active');
          manualScanToggle.setAttribute('aria-expanded', 'true');
          manualScanSection.setAttribute('aria-hidden', 'false');
          setStage(1, scanParameters || scanRoot);
          scrollToManualScanPanel(manualScanSection);
        };

        const closeManualScan = () => {
          if (!manualScanSection.classList.contains('is-open')) {
            return;
          }
          resetProgress();
          stopEventSource();
          stopPolling();
          clearWatchdog();
          isCompleted = false;
          terminalState = null;
          activeScanId = null;
          if (runButton) {
            runButton.disabled = false;
          }
          if (playlistInput) {
            playlistInput.value = '';
          }
          countryManager.reset();
          keywordManager.reset();
          manualScanSection.classList.remove('is-open');
          manualScanToggle.classList.remove('is-active');
          manualScanToggle.setAttribute('aria-expanded', 'false');
          manualScanSection.setAttribute('aria-hidden', 'true');
          playlistControls?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        manualScanToggle.addEventListener('click', () => {
          if (manualScanSection.classList.contains('is-open')) {
            closeManualScan();
          } else {
            openManualScan();
          }
        });

        manualScanCloseButton?.addEventListener('click', closeManualScan);
        window.addEventListener('beforeunload', () => {
          stopEventSource();
          stopPolling();
        });

        runButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          startManualScan();
        });
      };

      setupAddPanel();
      setupManagePanels();
      setupManualScanSection();
      };

      initTrackedPlaylistsPage();
    </script>
  </body>
</html>
