<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ playlist.name }} · Tracked Playlist</title>
    <link rel="stylesheet" href="/static/ui.css?v={{ build_id }}" />
    <link rel="stylesheet" href="/static/tracked.css?v={{ build_id }}" />
  </head>
  <body class="app-body">
    <main class="page">
      <header class="page-header">
        <div>
          <h1 class="page-title dashboard-title" title="{{ playlist.dashboard_header_title }}">
            <span class="dashboard-title-prefix">Dashboard</span>
          </h1>
        </div>
        <div class="page-header-actions">
          <button class="btn btn-tracked-outline dashboard-action-btn" type="button">Tracked Playlist</button>
          <button class="btn btn-primary dashboard-action-btn" type="button" data-refresh-stats>Refresh Stats</button>
          {% set label = 'Back To Tracked Playlists' %}
          {% set button_variant = 'ghost' %}
          {% set href = '/' %}
          {% set extra_class = 'btn-back-blue dashboard-action-btn' %}
          {% include "_components/button.html" %}
        </div>
      </header>

      <section class="ui-card status-card">
        <div class="status-card-header">
          <h2>Status</h2>
          <p class="status-card-subtitle">Live feedback for playlist actions.</p>
        </div>
        <div id="playlist-status" class="status-area" role="status" aria-live="polite">
          Ready to refresh playlist metadata.
        </div>
      </section>

      <div class="tracked-detail-stack">
        {% set variant = 'detail' %}
        {% include "_components/tracked_card.html" %}

        <section class="toolbar-panel">
          <div class="toolbar-actions">
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="dedicated"
              aria-pressed="false"
            >
              Dedicated Scan
            </button>
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="latest"
              aria-pressed="true"
            >
              Latest Scan Results
            </button>
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="history"
              aria-pressed="false"
            >
              Scan History
            </button>
          </div>
        </section>

        <section class="panel basic-scan-panel is-hidden" id="basic-scan-section">
          <div class="panel-header">
            <h2>Dedicated Scan</h2>
            <p>Run a manual scan using stored targets.</p>
          </div>
          <div class="panel-body">
            <div class="basic-scan" data-basic-scan data-tracked-playlist-id="{{ playlist.id }}">
              <section class="scan-parameters" id="scan-parameters" data-basic-scan-parameters>
                <div class="scan-config-row">
                  <span class="scan-config-label">Countries</span>
                  <div class="pill-list" data-basic-scan-countries>
                    {% if playlist.target_countries %}
                      {% for country in playlist.target_countries %}
                        {% set label = playlist.target_country_labels.get(country|upper, country) %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ label }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target countries</span>
                    {% endif %}
                  </div>
                </div>
                <div class="scan-config-row">
                  <span class="scan-config-label">Keywords</span>
                  <div class="pill-list" data-basic-scan-keywords>
                    {% if playlist.target_keywords %}
                      {% for keyword in playlist.target_keywords %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ keyword }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target keywords</span>
                    {% endif %}
                  </div>
                </div>
                <div class="run-scan-controls" id="run-scan-controls" data-basic-scan-run-controls>
                  <button class="btn btn-primary" type="button" data-basic-scan-run>
                    Run Dedicated Scan
                  </button>
                </div>
              </section>
              <section
                class="run-progress basic-scan-progress"
                id="basic-scan-progress"
                data-basic-scan-progress
                hidden
              >
                <div class="progress-bar">
                  <div class="progress-fill" data-basic-scan-progress-fill></div>
                </div>
                <div class="progress-status" data-basic-scan-progress-status>Starting scan…</div>
                <div class="progress-helper" data-basic-scan-progress-helper>
                  Your scan is still in progress. Estimating remaining time. Refresh this page soon to
                  see your scan results.
                </div>
                <div class="progress-log" data-basic-scan-progress-log></div>
                <div class="progress-actions">
                  <button
                    class="btn btn-secondary"
                    type="button"
                    data-basic-scan-stop
                    hidden
                  >
                    Stop Scan
                  </button>
                </div>
              </section>
            </div>
          </div>
        </section>

        <section class="panel latest-scan-panel is-active" id="latest-scan-section">
          <div class="panel-header">
            <h2>Latest Scan Results</h2>
            <p>Most recent completed scan, refreshed on every visit.</p>
          </div>
          <div class="panel-body">
            <div class="latest-scan" data-latest-scan data-tracked-playlist-id="{{ playlist.id }}">
              {% set results_id = 'latest-scan-results' %}
              {% set results_title = 'Latest Scan Results' %}
              {% set data_prefix = 'latest-scan' %}
              {% set csv_controls_id = 'latest-scan-csv-controls' %}
              {% set summary_id = 'latest-scan-summary' %}
              {% set detailed_id = 'latest-scan-detailed' %}
              {% include "_components/scan_results.html" %}
            </div>
          </div>
        </section>

        <section class="panel scan-history-panel is-hidden" id="scan-history-section">
          <div class="panel-header scan-history-header">
            <div>
              <h2>Scan History</h2>
              <p>Recent scan runs for this playlist.</p>
            </div>
            <div class="scan-history-actions">
              <button
                class="pill pill-primary"
                type="button"
                data-scan-history-compare-toggle
                aria-pressed="false"
              >
                Compare Results
              </button>
              <button
                class="pill pill-secondary"
                type="button"
                data-scan-history-compare-cancel
                hidden
              >
                Cancel
              </button>
              <button
                class="pill pill-primary scan-history-compare-run"
                type="button"
                data-scan-history-compare-run
                disabled
                hidden
              >
                Compare
              </button>
            </div>
          </div>
          <div class="panel-body">
            <div class="scan-history" data-scan-history data-tracked-playlist-id="{{ playlist.id }}">
              <div class="scan-history-list" data-scan-history-list>
                <p class="summary-note" data-scan-history-empty hidden>
                  No scan history yet for this playlist.
                </p>
                <div class="table-scroll" data-scan-history-table hidden>
                  <table class="results-table">
                    <thead>
                      <tr>
                        <th>Scan date</th>
                        <th>Country</th>
                        <th>Keyword</th>
                        <th data-scan-history-compare-column hidden></th>
                        <th>Status</th>
                      </tr>
                    </thead>
                    <tbody data-scan-history-body></tbody>
                  </table>
                </div>
              </div>
            </div>
            <section class="panel scan-history-compare-panel" data-scan-history-compare hidden>
              <div class="panel-header">
                <h2>Comparison Results</h2>
                <p>Review the differences between two scans.</p>
              </div>
              <div class="panel-body">
                <div class="scan-history-compare-actions">
                  <button class="btn btn-secondary" type="button" data-scan-history-compare-back>
                    Back to Scan History
                  </button>
                </div>
                <p class="summary-note scan-history-compare-message" data-scan-history-compare-message hidden></p>
                <div class="scan-history-compare-summary" data-scan-history-compare-summary></div>
                <div class="scan-history-compare-followers" data-scan-history-compare-followers hidden>
                  <table class="results-table comparison-table comparison-followers-table">
                    <thead>
                      <tr>
                        <th>Metric</th>
                        <th>Scan A</th>
                        <th>Scan B</th>
                        <th>Change</th>
                      </tr>
                    </thead>
                    <tbody data-scan-history-compare-followers-body></tbody>
                  </table>
                </div>
                <div class="table-scroll" data-scan-history-compare-table hidden>
                  <table class="results-table comparison-table">
                    <thead>
                      <tr>
                        <th>Country</th>
                        <th>Keyword</th>
                        <th>Rank A</th>
                        <th>Rank B</th>
                        <th>Position change</th>
                      </tr>
                    </thead>
                    <tbody data-scan-history-compare-body></tbody>
                  </table>
                </div>
              </div>
            </section>
            <section class="panel scan-history-detail-panel" data-scan-history-detail hidden>
              <div class="panel-header">
                <h2>Scan Details</h2>
                <p>Review a completed scan run.</p>
              </div>
              <div class="panel-body">
                <div class="scan-history-detail-actions">
                  <button class="btn btn-secondary" type="button" data-scan-history-back>
                    Back to Scan History
                  </button>
                </div>
                <p class="summary-note scan-history-detail-message" data-scan-history-detail-message hidden></p>
                <div class="scan-history-detail-results" data-scan-history-detail-results>
                  {% set results_id = 'scan-history-detail-results' %}
                  {% set results_title = 'Scan Details' %}
                  {% set data_prefix = 'history-detail' %}
                  {% set csv_controls_id = 'scan-history-detail-csv-controls' %}
                  {% set summary_id = 'scan-history-detail-summary' %}
                  {% set detailed_id = 'scan-history-detail-detailed' %}
                  {% include "_components/scan_results.html" %}
                </div>
              </div>
            </section>
          </div>
        </section>
      </div>
    </main>

    <script>
      const statusArea = document.getElementById('playlist-status');
      const refreshButton = document.querySelector('[data-refresh-stats]');
      const playlistDetailRoot = document.querySelector('[data-tracked-card][data-playlist-id]');
      const playlistId = playlistDetailRoot?.dataset.playlistId || null;
      const ownerValue = playlistDetailRoot?.querySelector('[data-playlist-owner]') || null;
      const followersValue = playlistDetailRoot?.querySelector('[data-playlist-followers]') || null;
      const tracksValue = playlistDetailRoot?.querySelector('[data-playlist-tracks]') || null;
      const scannedValue = playlistDetailRoot?.querySelector('[data-playlist-scanned]') || null;
      const updatedValue = playlistDetailRoot?.querySelector('[data-playlist-updated]') || null;
      const toolbarButtons = document.querySelectorAll('[data-panel-target]');
      const panels = document.querySelectorAll('.panel[data-panel]');
      const toolbar = document.querySelector('.toolbar-panel');
      let lastAnchor = toolbar;
      const basicScanSection = document.getElementById('basic-scan-section');
      const latestScanSection = document.getElementById('latest-scan-section');
      const scanHistorySection = document.getElementById('scan-history-section');
      const scanTabButtons = document.querySelectorAll('[data-scan-tab]');
      let basicScanStageController = null;
      let activeSection = null;
      let loadLatestScan = null;
      let loadScanHistory = null;
      let resetHistoryDetail = null;
      let resetHistoryCompare = null;
      let lastTabScrollY = null;
      let activeScanStatus = null;

      const togglePanel = (targetId) => {
        let activePanel = null;
        panels.forEach((panel) => {
          if (panel.id === targetId) {
            activePanel = panel;
          }
        });

        if (!activePanel) {
          return;
        }

        const isActive = activePanel.classList.contains('is-active');
        panels.forEach((panel) => panel.classList.remove('is-active'));

        if (!isActive) {
          lastAnchor = toolbar || document.body;
          activePanel.classList.add('is-active');
          activePanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          return;
        }

        if (lastAnchor) {
          lastAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      toolbarButtons.forEach((button) => {
        button.addEventListener('click', () => {
          togglePanel(button.dataset.panelTarget);
        });
      });

      if (panels.length) {
        panels[0].classList.add('is-active');
      }

      const showSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = false;
        section.style.removeProperty('display');
      };

      const hideSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = true;
        section.style.display = 'none';
      };

      const scrollSectionToCenter = (section) => {
        if (!section) {
          return;
        }
        const rect = section.getBoundingClientRect();
        const sectionTop = window.scrollY + rect.top;
        const target =
          sectionTop - window.innerHeight / 2 + rect.height / 2;
        window.scrollTo({ top: Math.max(target, 0), behavior: 'smooth' });
      };

      const setActiveSection = (nextTab, options = {}) => {
        if (!nextTab || nextTab === activeSection) {
          return;
        }
        if (
          nextTab !== 'dedicated' &&
          ['queued', 'running'].includes(activeScanStatus) &&
          !options.allowRunningSwitch
        ) {
          return;
        }
        if (nextTab !== 'history' && typeof resetHistoryDetail === 'function') {
          resetHistoryDetail({ skipScroll: true });
        }
        if (nextTab !== 'history' && typeof resetHistoryCompare === 'function') {
          resetHistoryCompare({ skipScroll: true });
        }
        lastTabScrollY = window.scrollY;
        activeSection = nextTab;

        const setSectionActive = (section, isActive) => {
          if (!section) {
            return;
          }
          section.classList.toggle('is-active', isActive);
          section.classList.toggle('is-hidden', !isActive);
        };

        setSectionActive(basicScanSection, nextTab === 'dedicated');
        setSectionActive(latestScanSection, nextTab === 'latest');
        setSectionActive(scanHistorySection, nextTab === 'history');

        if (nextTab === 'dedicated' && basicScanStageController) {
          basicScanStageController.setStage(basicScanStageController.getStage());
        }

        scanTabButtons.forEach((button) => {
          const isActive = button.dataset.scanTab === activeSection;
          button.setAttribute('aria-pressed', String(isActive));
          button.classList.toggle('is-active', isActive);
        });

        if (nextTab === 'latest' && !options.skipFetch && typeof loadLatestScan === 'function') {
          loadLatestScan();
        }
        if (nextTab === 'history' && !options.skipFetch && typeof loadScanHistory === 'function') {
          loadScanHistory();
        }

        if (!options.skipScroll && lastTabScrollY !== null) {
          window.scrollTo({ top: lastTabScrollY, behavior: 'smooth' });
        }
      };

      scanTabButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          const nextTab = button.dataset.scanTab;
          setActiveSection(nextTab);
        });
      });

      const setStatus = (message, variant) => {
        if (!statusArea) {
          return;
        }
        statusArea.textContent = message;
        statusArea.classList.remove('status-success', 'status-error', 'status-loading');
        if (variant) {
          statusArea.classList.add(variant);
        }
      };

      const readErrorPayload = async (response) => {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          try {
            return await response.json();
          } catch (error) {
            return null;
          }
        }
        try {
          const text = await response.text();
          return text || null;
        } catch (error) {
          return null;
        }
      };

      const parseJsonSafely = async (response) => {
        try {
          return await response.json();
        } catch (error) {
          return null;
        }
      };

      const normalizeErrorMessage = (payload, fallback) => {
        if (!payload) {
          return fallback;
        }
        if (typeof payload === 'string') {
          return payload;
        }
        const detail = payload.detail ?? payload.message ?? payload.error ?? payload;
        if (typeof detail === 'string') {
          return detail;
        }
        try {
          return JSON.stringify(detail);
        } catch (error) {
          return fallback;
        }
      };

      const formatFollowersValue = (value) => {
        if (value === undefined || value === null || value === '') {
          return '—';
        }
        if (typeof value === 'object') {
          if ('total' in value) {
            return formatFollowersValue(value.total);
          }
          return '—';
        }
        const numeric = Number(value);
        if (Number.isFinite(numeric)) {
          return numeric.toLocaleString();
        }
        return value;
      };

      const formatRelativeTime = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '—';
        }
        const deltaSeconds = Math.max(0, Math.floor((Date.now() - date.getTime()) / 1000));
        if (deltaSeconds < 60) {
          return 'just now';
        }
        const minutes = Math.floor(deltaSeconds / 60);
        if (minutes < 60) {
          return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} ago`;
        }
        const hours = Math.floor(minutes / 60);
        if (hours < 24) {
          return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`;
        }
        const days = Math.floor(hours / 24);
        return `${days} ${days === 1 ? 'day' : 'days'} ago`;
      };

      const captureDomSnapshot = () => ({
        owner: ownerValue?.textContent?.trim() || '',
        followers: followersValue?.textContent?.trim() || '',
        tracks: tracksValue?.textContent?.trim() || '',
        scanned: scannedValue?.textContent?.trim() || '',
        updated: updatedValue?.textContent?.trim() || '',
      });

      const buildDataSnapshot = (data) => ({
        owner: data?.owner_name || '—',
        followers: formatFollowersValue(data?.followers_total),
        tracks: formatFollowersValue(data?.tracks_count),
        scanned: formatRelativeTime(data?.stats_updated_at),
        updated: formatRelativeTime(data?.playlist_last_updated_at),
      });

      const snapshotsDiffer = (next, baseline) =>
        Object.keys(baseline || {}).some((key) => (next?.[key] || '') !== (baseline?.[key] || ''));

      const applyPlaylistData = (data) => {
        if (!data) {
          return;
        }
        if (ownerValue) {
          ownerValue.textContent = data.owner_name || '—';
        }
        if (followersValue) {
          followersValue.textContent = formatFollowersValue(data.followers_total);
        }
        if (tracksValue) {
          tracksValue.textContent = formatFollowersValue(data.tracks_count);
        }
        if (scannedValue) {
          scannedValue.textContent = formatRelativeTime(data.stats_updated_at);
        }
        if (updatedValue) {
          updatedValue.textContent = formatRelativeTime(data.playlist_last_updated_at);
        }
      };

      const fetchPlaylistDetail = async () => {
        if (!playlistId) {
          return null;
        }
        const response = await fetch('/api/playlists');
        if (!response.ok) {
          return null;
        }
        const payload = await parseJsonSafely(response);
        if (!Array.isArray(payload)) {
          return null;
        }
        return payload.find((item) => String(item.id) === String(playlistId)) || null;
      };

      const pollForPlaylistUpdate = async (baselineSnapshot, baselineRefreshAt) => {
        const POLL_INTERVAL_MS = 2000;
        const MAX_ATTEMPTS = 30;
        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
          try {
            const data = await fetchPlaylistDetail();
            if (data) {
              const currentSnapshot = buildDataSnapshot(data);
              const refreshAt = data.last_meta_refresh_at || null;
              if (
                snapshotsDiffer(currentSnapshot, baselineSnapshot) ||
                (baselineRefreshAt && refreshAt && refreshAt !== baselineRefreshAt)
              ) {
                applyPlaylistData(data);
                return { updated: true, data };
              }
            }
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[ui] refresh stats polling failed', error);
            }
          }
          await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL_MS));
        }
        return { updated: false, data: null };
      };

      refreshButton?.addEventListener('click', async () => {
        if (!refreshButton || !playlistDetailRoot || !playlistId) {
          return;
        }
        refreshButton.disabled = true;
        setStatus('Fetching data from Spotify… please wait', 'status-loading');
        let didUpdate = false;
        let baselineSnapshot = captureDomSnapshot();
        let baselineRefreshAt = null;

        try {
          const preRefreshData = await fetchPlaylistDetail();
          if (preRefreshData) {
            baselineSnapshot = buildDataSnapshot(preRefreshData);
            baselineRefreshAt = preRefreshData.last_meta_refresh_at || null;
          }
          const response = await fetch(`/api/playlists/{{ playlist.id }}/refresh-stats`, {
            method: 'POST',
          });
          if (!response.ok) {
            const errorPayload = await readErrorPayload(response);
            const message = normalizeErrorMessage(
              errorPayload,
              'Unable to refresh playlist metadata.'
            );
            setStatus(message, 'status-error');
            return;
          }

          let data = null;
          data = await parseJsonSafely(response);
          const refreshedAt =
            data && typeof data === 'object' && data.refreshed_at ? new Date(data.refreshed_at) : null;
          const queuedAt =
            data && typeof data === 'object' && data.queued_at ? new Date(data.queued_at) : null;
          if (refreshedAt) {
            const timeLabel = refreshedAt.toLocaleString();
            setStatus(`✅ Playlist metadata refreshed at ${timeLabel}`, 'status-success');
          } else {
            const queuedLabel = queuedAt ? queuedAt.toLocaleString() : 'just now';
            const statusLabel =
              data && typeof data === 'object' && data.status === 'already_running'
                ? 'Already running'
                : 'Queued';
            setStatus(`⏳ ${statusLabel}: refresh scheduled at ${queuedLabel}.`, 'status-success');
          }

          const pollResult = await pollForPlaylistUpdate(baselineSnapshot, baselineRefreshAt);
          if (pollResult.updated) {
            didUpdate = true;
            setStatus('✅ Playlist stats updated.', 'status-success');
          } else {
            setStatus(
              'Refresh completed, but UI update timed out. Please reload.',
              'status-error'
            );
          }
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[ui] refresh stats failed', error);
          }
          const message = normalizeErrorMessage(
            error,
            'Network error while refreshing playlist.'
          );
          setStatus(message, 'status-error');
        } finally {
          refreshButton.disabled = false;
          if (!didUpdate && statusArea?.classList.contains('status-loading')) {
            setStatus('Unable to refresh playlist metadata.', 'status-error');
          }
        }
      });

      const availableMarkets = {{ available_markets | tojson }};
      const marketLabelMap = new Map(
        availableMarkets.map((market) => [market.code.toUpperCase(), market.label])
      );

      const resolveMarketLabel = (code) => marketLabelMap.get((code || '').toUpperCase()) || code;

      const formatTimestamp = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return new Intl.DateTimeFormat('sv-SE', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);
      };

      const formatSummaryDateParts = (value) => {
        if (!value) {
          return { dateLabel: '—', timeLabel: '—' };
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return { dateLabel: value, timeLabel: value };
        }
        const dateLabel = date.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        });
        const timeLabel = date.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
        });
        return { dateLabel, timeLabel };
      };

      const formatFileTimestamp = (value) => {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        const pad = (part) => String(part).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${day}-${month}-${year}_${hours}-${minutes}`;
      };

      const flagEmoji = (code) => {
        const upper = (code || '').toUpperCase();
        if (upper.length !== 2) {
          return '';
        }
        return upper.replace(/./g, (char) => String.fromCodePoint(127397 + char.charCodeAt()));
      };

      const setupBasicScan = () => {
        const scanRoot = document.querySelector('[data-basic-scan]');
        const latestRoot = document.querySelector('[data-latest-scan]');
        const historyRoot = document.querySelector('[data-scan-history]');
        const historyDetailPanel = document.querySelector('[data-scan-history-detail]');
        if (!scanRoot) {
          return;
        }
        const scanParameters = scanRoot.querySelector('[data-basic-scan-parameters]');
        const runControls = scanRoot.querySelector('[data-basic-scan-run-controls]');
        const runButton = scanRoot.querySelector('[data-basic-scan-run]');
        const progressWrap = scanRoot.querySelector('[data-basic-scan-progress]');
        const progressFill = scanRoot.querySelector('[data-basic-scan-progress-fill]');
        const progressStatus = scanRoot.querySelector('[data-basic-scan-progress-status]');
        const progressHelper = scanRoot.querySelector('[data-basic-scan-progress-helper]');
        const progressLog = scanRoot.querySelector('[data-basic-scan-progress-log]');
        const stopButton = scanRoot.querySelector('[data-basic-scan-stop]');
        const buildScanElements = (prefix, root) => ({
          resultsWrap: root?.querySelector(`[data-${prefix}-results]`),
          summaryLead: root?.querySelector(`[data-${prefix}-summary-lead]`),
          summaryList: root?.querySelector(`[data-${prefix}-summary-list]`),
          detailedWrap: root?.querySelector(`[data-${prefix}-detailed]`),
          exportSummary: root?.querySelector(`[data-${prefix}-export-summary]`),
          exportDetailed: root?.querySelector(`[data-${prefix}-export-detailed]`),
          summarySection: root?.querySelector(`[data-${prefix}-summary-section]`),
          detailedSection: root?.querySelector(`[data-${prefix}-detailed-section]`),
          csvControls: root?.querySelector(`[data-${prefix}-csv-controls]`),
        });
        const latestResults = buildScanElements('latest-scan', latestRoot);
        const historyDetailRoot = historyDetailPanel?.querySelector('[data-scan-history-detail-results]');
        const historyDetailElements = buildScanElements('history-detail', historyDetailRoot);
        const historyElements = {
          table: historyRoot?.querySelector('[data-scan-history-table]'),
          body: historyRoot?.querySelector('[data-scan-history-body]'),
          empty: historyRoot?.querySelector('[data-scan-history-empty]'),
          list: historyRoot?.querySelector('[data-scan-history-list]'),
        };
        const historyCompareElements = {
          toggle: scanHistorySection?.querySelector('[data-scan-history-compare-toggle]'),
          cancel: scanHistorySection?.querySelector('[data-scan-history-compare-cancel]'),
          run: scanHistorySection?.querySelector('[data-scan-history-compare-run]'),
          column: scanHistorySection?.querySelector('[data-scan-history-compare-column]'),
          panel: scanHistorySection?.querySelector('[data-scan-history-compare]'),
          back: scanHistorySection?.querySelector('[data-scan-history-compare-back]'),
          message: scanHistorySection?.querySelector('[data-scan-history-compare-message]'),
          summary: scanHistorySection?.querySelector('[data-scan-history-compare-summary]'),
          followers: scanHistorySection?.querySelector('[data-scan-history-compare-followers]'),
          followersBody: scanHistorySection?.querySelector(
            '[data-scan-history-compare-followers-body]'
          ),
          table: scanHistorySection?.querySelector('[data-scan-history-compare-table]'),
          body: scanHistorySection?.querySelector('[data-scan-history-compare-body]'),
        };
        const historyDetailMessage = historyDetailPanel?.querySelector(
          '[data-scan-history-detail-message]'
        );
        const historyDetailBackButton = historyDetailPanel?.querySelector('[data-scan-history-back]');
        const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        let activeScanId = null;
        let eventSource = null;
        let currentStage = 1;
        let watchdogTimer = null;
        let lastMessageAt = null;
        let hasStopped = false;
        let lastProgressSnapshot = null;
        let pollTimer = null;
        let pollActiveScanId = null;
        let pollInFlight = false;
        let pollStartAt = null;
        let etaMsFromServer = null;
        let etaMsLive = null;
        let etaTickInterval = null;
        let selectedHistoryScanId = null;
        let historyDetailRequestId = 0;
        let compareMode = false;
        let selectedCompareScanIds = [];
        let compareLoading = false;
        let compareError = null;
        let compareData = null;
        let compareRequestId = 0;
        let latestHistoryItems = [];
        const WATCHDOG_MS = 45000;
        const WATCHDOG_CHECK_MS = 5000;

        const setStage = (stage, scrollTarget) => {
          currentStage = stage;
          const showStage1 = stage === 1;
          const showStage2 = stage === 2;

          if (showStage1) {
            showSection(scanParameters);
            showSection(runControls);
            hideSection(progressWrap);
          }

          if (showStage2) {
            hideSection(scanParameters);
            hideSection(runControls);
            showSection(progressWrap);
          }

          const target =
            scrollTarget || (showStage1 ? scanParameters || scanRoot : progressWrap || scanRoot);
          scrollSectionToCenter(target);
        };
        basicScanStageController = { setStage, getStage: () => currentStage };

        const openBasicScanStage1 = () => {
          setStage(1, scanParameters || scanRoot);
        };

        const openBasicScanStage2 = () => {
          setStage(2, progressWrap || scanRoot);
        };

        const computeEtaMinutes = (etaMs) => {
          if (!Number.isFinite(etaMs)) {
            return null;
          }
          const clampedMs = Math.max(0, etaMs);
          if (clampedMs <= 0) {
            return null;
          }
          const minutes = Math.ceil(clampedMs / 60000);
          if (clampedMs > 0 && minutes < 1) {
            return 1;
          }
          return minutes;
        };

        const updateProgressHelper = (etaMsValue = null) => {
          if (!progressHelper) {
            return;
          }
          const minutes = computeEtaMinutes(etaMsValue);
          if (minutes !== null) {
            progressHelper.textContent = `Your scan is still in progress. Estimated time remaining: ${minutes} minutes. Refresh this page in ${minutes} minutes to see your scan results.`;
          } else {
            progressHelper.textContent =
              'Your scan is still in progress. Refresh this page in a few minutes to see your scan results.';
          }
        };

        const setEtaMsFromServer = (etaMs) => {
          if (Number.isFinite(etaMs)) {
            etaMsFromServer = Math.max(etaMs, 0);
            etaMsLive = etaMsFromServer;
          } else {
            etaMsFromServer = null;
            etaMsLive = null;
          }
          updateProgressHelper(etaMsLive);
        };

        const stopEtaTick = () => {
          if (etaTickInterval) {
            clearInterval(etaTickInterval);
            etaTickInterval = null;
          }
        };

        const startEtaTick = () => {
          if (etaTickInterval) {
            return;
          }
          etaTickInterval = setInterval(() => {
            if (!['queued', 'running'].includes(activeScanStatus)) {
              stopEtaTick();
              return;
            }
            if (!Number.isFinite(etaMsLive)) {
              return;
            }
            etaMsLive = Math.max(0, etaMsLive - 1000);
            updateProgressHelper(etaMsLive);
          }, 1000);
        };

        const syncEtaTicker = () => {
          if (['queued', 'running'].includes(activeScanStatus)) {
            startEtaTick();
          } else {
            stopEtaTick();
          }
        };

        const updateEta = (progress) => {
          const etaMs = progress?.eta_ms;
          if (Number.isFinite(etaMs)) {
            setEtaMsFromServer(etaMs);
            return;
          }
          updateProgressHelper(etaMsLive);
        };

        const buildProgressMessage = (message) => message || 'Scanning...';

        const setProgress = (current, total, message, progress = null) => {
          if (!progressWrap) {
            return;
          }
          lastProgressSnapshot = {
            completed_units: current,
            total_units: total,
            progress_pct: total ? Math.min((current / total) * 100, 100) : 0,
            eta_ms: progress?.eta_ms,
            eta_human: progress?.eta_human,
          };
          const percent = total ? Math.min((current / total) * 100, 100) : 0;
          if (progressFill) {
            progressFill.style.width = `${percent}%`;
          }
          if (progressStatus) {
            progressStatus.textContent = buildProgressMessage(message);
          }
          updateEta(progress);
        };

        const appendLog = (message) => {
          if (!progressLog || !message) {
            return;
          }
          const entry = document.createElement('div');
          entry.className = 'progress-log-entry';
          entry.textContent = message;
          progressLog.appendChild(entry);
          progressLog.scrollTop = progressLog.scrollHeight;
        };

        const hasResults = (scan) => {
          if (!scan || typeof scan !== 'object') {
            return false;
          }
          const summary = scan.summary || scan.results?.summary;
          if (Array.isArray(summary)) {
            return summary.length > 0;
          }
          const detailed = scan.detailed || scan.results?.detailed;
          if (detailed && typeof detailed === 'object') {
            return Object.keys(detailed).length > 0;
          }
          return false;
        };

        const logScanState = (scan, scanIdOverride = null) => {
          const scanId = scanIdOverride || scan?.scan_id || 'unknown';
          const status = scan?.status ?? 'unknown';
          const completedAt = scan?.completed_at || scan?.finished_at || null;
          const resultsSource = scan?.results || scan;
          const hasResultsValue = hasResults(resultsSource);
          if (typeof console !== 'undefined' && console.debug) {
            console.debug(
              '[UI_SCAN_STATE]',
              scanId,
              status,
              completedAt,
              hasResultsValue
            );
          }
          return { status, completedAt, hasResultsValue };
        };

        const isScanComplete = (scan, scanIdOverride = null) => {
          const { status, completedAt, hasResultsValue } = logScanState(
            scan,
            scanIdOverride
          );
          return status === 'completed' && Boolean(completedAt) && hasResultsValue;
        };

        const logSwitchLatest = (scanId, reason) => {
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[UI_SWITCH_LATEST]', scanId || 'none', reason);
          }
        };

        const applyProgressSnapshot = (progress, messageOverride) => {
          if (!progress || typeof progress !== 'object') {
            return;
          }
          const completed = progress.completed_units ?? 0;
          const total = progress.total_units ?? 0;
          const message = messageOverride || 'Scan in progress...';
          setProgress(completed, total, message, progress);
        };

        const setStopButtonVisible = (visible) => {
          if (!stopButton) {
            return;
          }
          stopButton.hidden = !visible;
          stopButton.disabled = !visible;
        };

        const stopPolling = () => {
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
          pollStartAt = null;
          pollActiveScanId = null;
          pollInFlight = false;
        };

        const startCompletionPoll = (scanId) => {
          if (!scanId) {
            return;
          }
          stopPolling();
          pollActiveScanId = scanId;
          pollStartAt = Date.now();
          pollTimer = setInterval(async () => {
            if (!pollActiveScanId || pollInFlight) {
              return;
            }
            if (Date.now() - pollStartAt > 10 * 60 * 1000) {
              stopPolling();
              return;
            }
            pollInFlight = true;
            try {
              const response = await fetch(
                `/api/basic-rank-checker/scans/${pollActiveScanId}`
              );
              const data = await readErrorPayload(response);
              if (!response.ok) {
                throw new Error(
                  normalizeErrorMessage(data, 'Unable to check scan status.')
                );
              }
              if (data?.progress) {
                applyProgressSnapshot(data.progress);
              }
              activeScanStatus = data?.status || activeScanStatus;
              syncEtaTicker();
              if (isScanComplete(data, pollActiveScanId)) {
                await safeStop('completed', {
                  scanId: pollActiveScanId,
                  switchReason: 'poll_completed',
                });
                stopPolling();
              } else if (data?.status === 'failed') {
                appendLog('Scan failed.');
                await safeStop('scan failed');
                stopPolling();
              } else if (data?.status === 'cancelled') {
                appendLog('Scan cancelled.');
                await safeStop('cancelled', { scanId: pollActiveScanId });
                stopPolling();
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.debug) {
                console.debug('[basic-scan] polling error', error);
              }
            } finally {
              pollInFlight = false;
            }
          }, 5000);
        };

        const clearWatchdog = () => {
          if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
          }
          lastMessageAt = null;
        };

        const startWatchdog = () => {
          clearWatchdog();
          lastMessageAt = Date.now();
          watchdogTimer = setInterval(() => {
            if (!lastMessageAt) {
              return;
            }
            if (Date.now() - lastMessageAt > WATCHDOG_MS) {
              safeStop('timeout');
            }
          }, WATCHDOG_CHECK_MS);
        };

        const updateLastMessageAt = () => {
          lastMessageAt = Date.now();
        };

        const safeStop = async (reason, options = {}) => {
          if (hasStopped) {
            return;
          }
          hasStopped = true;
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          clearWatchdog();
          stopPolling();
          stopEtaTick();
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          setStopButtonVisible(false);

          const statusMessages = {
            completed: '✅ Dedicated scan completed.',
            timeout: 'Dedicated scan timed out. Please try again.',
            'connection error': 'Dedicated scan connection lost. Please try again.',
            'handler error': 'Dedicated scan failed. Please try again.',
            'scan failed': 'Dedicated scan failed. Please try again.',
            cancelled: 'Scan cancelled.',
          };
          const statusMessage = statusMessages[reason] || 'Basic Scan stopped.';
          const variant =
            reason === 'completed' || reason === 'cancelled' ? 'status-success' : 'status-error';

          if (reason === 'completed') {
            activeScanStatus = 'completed';
            syncEtaTicker();
            setProgress(options.total || 1, options.total || 1, 'Scan completed.', { eta_ms: 0 });
            setStage(1, scanParameters || scanRoot);
            logSwitchLatest(options.scanId || activeScanId, options.switchReason || 'completed');
            setActiveSection('latest', {
              skipScroll: true,
              skipFetch: true,
              allowRunningSwitch: true,
            });
            if (typeof loadLatestScan === 'function') {
              await loadLatestScan();
            }
          } else if (reason === 'cancelled') {
            activeScanStatus = 'cancelled';
            syncEtaTicker();
            if (lastProgressSnapshot) {
              setProgress(
                lastProgressSnapshot.completed_units || 0,
                lastProgressSnapshot.total_units || 1,
                statusMessage,
                lastProgressSnapshot
              );
            } else {
              setProgress(0, 1, statusMessage);
            }
            setStage(1, scanParameters || scanRoot);
          } else {
            activeScanStatus = 'failed';
            syncEtaTicker();
            setProgress(0, 1, statusMessage);
            setStage(1, scanParameters || scanRoot);
          }

          if (runButton) {
            runButton.disabled = false;
          }
          activeScanId = null;
          setStatus(statusMessage, variant);
        };

        const renderSummary = (scan, elements) => {
          const summaryLeadEl = elements?.summaryLead;
          const summaryListEl = elements?.summaryList;
          if (!summaryLeadEl || !summaryListEl) {
            return;
          }
          const follower = scan.follower_snapshot ?? '—';
          summaryLeadEl.textContent = `At ${formatTimestamp(
            scan.started_at
          )}, your playlist follower count was ${follower}.`;
          summaryListEl.innerHTML = '';
          (scan.summary || []).forEach((item) => {
            const row = document.createElement('div');
            row.className = `summary-row ${item.tracked_found_in_top20 ? '' : 'summary-row-missing'}`;
            const countryLabel = resolveMarketLabel(item.country);
            const { dateLabel, timeLabel } = formatSummaryDateParts(item.searched_at);
            const rankText = item.tracked_found_in_top20
              ? `your playlist rank was #${item.tracked_rank}.`
              : 'your playlist was not found in the top 20.';
            row.textContent = `On ${dateLabel} at ${timeLabel} in ${countryLabel} for ‘${item.keyword}’, ${rankText}`;
            summaryListEl.appendChild(row);
          });
        };

        const resolveFollowers = (result) => {
          const nestedFollowers =
            result.followers && typeof result.followers === 'object'
              ? result.followers.total
              : undefined;
          const nestedPlaylistFollowers =
            result.playlist && typeof result.playlist === 'object'
              ? result.playlist.followers || result.playlist.followers_total || result.playlist.follower_count
              : undefined;
          const nestedPlaylistFollowersTotal =
            nestedPlaylistFollowers && typeof nestedPlaylistFollowers === 'object'
              ? nestedPlaylistFollowers.total
              : undefined;
          const candidate =
            result.playlist_followers ??
            result.followers_total ??
            result.followers_count ??
            result.follower_count ??
            nestedFollowers ??
            nestedPlaylistFollowersTotal ??
            nestedPlaylistFollowers ??
            result.followers;
          return formatFollowersValue(candidate);
        };

        const renderDetailed = (scan, elements) => {
          const detailedWrapEl = elements?.detailedWrap;
          if (!detailedWrapEl) {
            return;
          }
          detailedWrapEl.innerHTML = '';
          const detailed = scan.detailed || {};
          const countryAccordions = [];
          Object.values(detailed).forEach((countryData) => {
            const countryCode = countryData.country;
            const countryDetails = document.createElement('details');
            countryDetails.className = 'accordion';
            const summary = document.createElement('summary');
            summary.textContent = `${flagEmoji(countryCode)} ${resolveMarketLabel(countryCode)}`;
            countryDetails.addEventListener('toggle', () => {
              if (!countryDetails.open) {
                return;
              }
              countryAccordions.forEach((openDetails) => {
                if (openDetails !== countryDetails) {
                  openDetails.open = false;
                }
              });
              requestAnimationFrame(() => {
                scrollSectionToCenter(countryDetails);
              });
            });
            countryDetails.appendChild(summary);
            countryAccordions.push(countryDetails);

            const keywordContainer = document.createElement('div');
            keywordContainer.className = 'accordion-body';
            const keywordAccordions = [];

            Object.entries(countryData.keywords || {}).forEach(([keyword, keywordData]) => {
              const keywordDetails = document.createElement('details');
              keywordDetails.className = 'accordion nested';
              const keywordSummary = document.createElement('summary');
              keywordSummary.textContent = `${keyword} · ${formatTimestamp(keywordData.searched_at)}`;
              keywordDetails.appendChild(keywordSummary);
              keywordDetails.addEventListener('toggle', () => {
                if (!keywordDetails.open) {
                  return;
                }
                keywordAccordions.forEach((openKeyword) => {
                  if (openKeyword !== keywordDetails) {
                    openKeyword.open = false;
                  }
                });
                requestAnimationFrame(() => {
                  scrollSectionToCenter(keywordDetails);
                });
              });

              const table = document.createElement('table');
              table.className = 'results-table';
              table.innerHTML = `
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Playlist</th>
                    <th>Owner</th>
                    <th>Followers</th>
                    <th>Songs</th>
                  </tr>
                </thead>
                <tbody></tbody>
              `;
              const tbody = table.querySelector('tbody');
              (keywordData.results || []).forEach((result) => {
                const followersValue = resolveFollowers(result);
                const row = document.createElement('tr');
                if (result.is_tracked_playlist) {
                  row.classList.add('tracked-highlight');
                }
                row.innerHTML = `
                  <td>${result.rank ?? '—'}</td>
                  <td>
                    ${
                      result.playlist_url
                        ? `<a href="${result.playlist_url}" target="_blank" rel="noopener noreferrer">${result.playlist_name || '—'}</a>`
                        : result.playlist_name || '—'
                    }
                  </td>
                  <td>${result.playlist_owner || '—'}</td>
                  <td>${followersValue}</td>
                  <td>${result.songs_count ?? '—'}</td>
                `;
                tbody.appendChild(row);
              });

              const tableScroll = document.createElement('div');
              tableScroll.className = 'table-scroll';
              tableScroll.appendChild(table);

              const keywordBody = document.createElement('div');
              keywordBody.className = 'accordion-body';
              keywordBody.appendChild(tableScroll);
              keywordDetails.appendChild(keywordBody);
              keywordContainer.appendChild(keywordDetails);
              keywordAccordions.push(keywordDetails);
            });

            countryDetails.appendChild(keywordContainer);
            detailedWrapEl.appendChild(countryDetails);
          });
        };

        const updateExportLinks = (scanId, startedAt, elements) => {
          const exportSummaryEl = elements?.exportSummary;
          const exportDetailedEl = elements?.exportDetailed;
          const timestamp = formatFileTimestamp(startedAt);
          const effectiveScanId = scanId || 'scan';
          const filenameBase = timestamp
            ? `${timestamp}_${effectiveScanId}`
            : `${effectiveScanId}`;
          const buildExportUrl = (path) => {
            const url = new URL(path, window.location.origin);
            if (timeZone) {
              url.searchParams.set('timezone', timeZone);
            }
            return `${url.pathname}${url.search}`;
          };
          if (exportSummaryEl) {
            exportSummaryEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/summary.csv`
            );
            exportSummaryEl.download = `${filenameBase}_summary.csv`;
          }
          if (exportDetailedEl) {
            exportDetailedEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/detailed.csv`
            );
            exportDetailedEl.download = `${filenameBase}_detailed.csv`;
          }
        };

        const renderScanResults = (scan, elements, scanId) => {
          if (!scan || typeof scan !== 'object') {
            return;
          }
          renderSummary(scan, elements);
          renderDetailed(scan, elements);
          if (elements?.summaryList) {
            elements.summaryList.hidden = false;
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = false;
          }
          if (elements?.csvControls) {
            showSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
          const startedAt =
            scan.started_at || scan.searched_at || scan.summary?.[0]?.searched_at;
          updateExportLinks(scanId, startedAt, elements);
        };

        const showEmptyState = (elements, message) => {
          if (elements?.summaryLead) {
            elements.summaryLead.textContent = message;
            elements.summaryLead.hidden = false;
          }
          if (elements?.summaryList) {
            elements.summaryList.innerHTML = '';
            elements.summaryList.hidden = true;
          }
          if (elements?.detailedWrap) {
            elements.detailedWrap.innerHTML = '';
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = true;
          }
          if (elements?.csvControls) {
            hideSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
        };

        const setHistoryDetailMessage = (message, { isError = false } = {}) => {
          if (!historyDetailMessage) {
            return;
          }
          historyDetailMessage.textContent = message || '';
          historyDetailMessage.hidden = !message;
          historyDetailMessage.classList.toggle('is-error', Boolean(message) && isError);
        };

        const clearHistoryDetailResults = () => {
          if (!historyDetailElements) {
            return;
          }
          if (historyDetailElements.summaryLead) {
            historyDetailElements.summaryLead.textContent = '';
            historyDetailElements.summaryLead.hidden = false;
          }
          if (historyDetailElements.summaryList) {
            historyDetailElements.summaryList.innerHTML = '';
            historyDetailElements.summaryList.hidden = true;
          }
          if (historyDetailElements.detailedWrap) {
            historyDetailElements.detailedWrap.innerHTML = '';
          }
          if (historyDetailElements.detailedSection) {
            historyDetailElements.detailedSection.hidden = true;
          }
          if (historyDetailElements.csvControls) {
            hideSection(historyDetailElements.csvControls);
          }
          if (historyDetailElements.resultsWrap) {
            historyDetailElements.resultsWrap.hidden = true;
          }
        };

        const setHistoryCompareMessage = (message, { isError = false } = {}) => {
          if (!historyCompareElements.message) {
            return;
          }
          historyCompareElements.message.textContent = message || '';
          historyCompareElements.message.hidden = !message;
          historyCompareElements.message.classList.toggle('is-error', Boolean(message) && isError);
        };

        const clearHistoryCompareResults = () => {
          if (historyCompareElements.summary) {
            historyCompareElements.summary.innerHTML = '';
          }
          if (historyCompareElements.followersBody) {
            historyCompareElements.followersBody.innerHTML = '';
          }
          if (historyCompareElements.followers) {
            historyCompareElements.followers.hidden = true;
          }
          if (historyCompareElements.body) {
            historyCompareElements.body.innerHTML = '';
          }
          if (historyCompareElements.table) {
            historyCompareElements.table.hidden = true;
          }
        };

        const showHistoryComparePanel = () => {
          if (!historyCompareElements.panel) {
            return;
          }
          historyCompareElements.panel.hidden = false;
          historyCompareElements.panel.classList.add('is-active');
        };

        const hideHistoryComparePanel = () => {
          if (!historyCompareElements.panel) {
            return;
          }
          historyCompareElements.panel.classList.remove('is-active');
          historyCompareElements.panel.hidden = true;
        };

        const showHistoryDetailPanel = () => {
          if (!historyDetailPanel) {
            return;
          }
          historyDetailPanel.hidden = false;
          historyDetailPanel.classList.add('is-active');
        };

        const hideHistoryDetailPanel = () => {
          if (!historyDetailPanel) {
            return;
          }
          historyDetailPanel.classList.remove('is-active');
          historyDetailPanel.hidden = true;
        };

        const updateCompareControls = () => {
          if (historyCompareElements.toggle) {
            historyCompareElements.toggle.classList.toggle('is-active', compareMode);
            historyCompareElements.toggle.setAttribute('aria-pressed', String(compareMode));
            historyCompareElements.toggle.hidden = compareMode;
          }
          if (historyCompareElements.cancel) {
            historyCompareElements.cancel.hidden = !compareMode;
          }
          if (historyCompareElements.run) {
            const compareReady = selectedCompareScanIds.length === 2 && !compareLoading;
            historyCompareElements.run.hidden = !compareMode;
            historyCompareElements.run.disabled = !compareReady;
            historyCompareElements.run.classList.toggle('compare-btn-enabled', compareReady);
            historyCompareElements.run.classList.toggle('compare-btn-disabled', !compareReady);
          }
        };

        const applyCompareSelectionState = () => {
          if (!historyElements.body) {
            return;
          }
          const limitReached = selectedCompareScanIds.length >= 2;
          const checkboxes = historyElements.body.querySelectorAll('[data-scan-history-checkbox]');
          checkboxes.forEach((checkbox) => {
            const isSelected = selectedCompareScanIds.includes(checkbox.value);
            checkbox.checked = isSelected;
            checkbox.disabled = compareLoading || (!isSelected && limitReached);
          });
        };

        const setCompareMode = (enabled, { skipScroll = false } = {}) => {
          compareMode = enabled;
          selectedCompareScanIds = [];
          compareLoading = false;
          compareError = null;
          compareData = null;
          compareRequestId += 1;
          setHistoryCompareMessage('');
          clearHistoryCompareResults();
          hideHistoryComparePanel();
          if (typeof resetHistoryDetail === 'function') {
            resetHistoryDetail({ skipScroll: true, scrollTarget: scanHistorySection || historyRoot });
          }
          if (historyElements.list) {
            showSection(historyElements.list);
          }
          if (historyCompareElements.column) {
            historyCompareElements.column.hidden = !compareMode;
          }
          renderScanHistory(latestHistoryItems);
          updateCompareControls();
          applyCompareSelectionState();
          if (!skipScroll) {
            scrollSectionToCenter(scanHistorySection || historyRoot);
          }
        };

        const renderCompareSummaryCard = (scan, label) => {
          const scanDate = formatTimestamp(scan?.created_at || scan?.started_at || scan?.finished_at);
          const statusLabel = formatScanHistoryStatus(scan?.status);
          const countriesCount = Array.isArray(scan?.scanned_countries)
            ? scan.scanned_countries.length
            : '—';
          const keywordsCount = Array.isArray(scan?.scanned_keywords)
            ? scan.scanned_keywords.length
            : '—';

          return `
            <div class="scan-history-compare-card">
              <h4>${label}</h4>
              <dl>
                <div>
                  <dt>Scan date</dt>
                  <dd>${scanDate}</dd>
                </div>
                <div>
                  <dt>Status</dt>
                  <dd>${statusLabel}</dd>
                </div>
                <div>
                  <dt>Countries</dt>
                  <dd>${countriesCount}</dd>
                </div>
                <div>
                  <dt>Keywords</dt>
                  <dd>${keywordsCount}</dd>
                </div>
              </dl>
            </div>
          `;
        };

        const renderCompareOverviewCard = ({
          followersChange,
          improvedCount,
          worsenedCount,
          unchangedCount,
        }) => `
          <div class="scan-history-compare-card">
            <h4>Summary</h4>
            <dl>
              <div>
                <dt>Followers</dt>
                <dd>${followersChange}</dd>
              </div>
              <div>
                <dt>Improved keywords</dt>
                <dd>${improvedCount}</dd>
              </div>
              <div>
                <dt>Worsened keywords</dt>
                <dd>${worsenedCount}</dd>
              </div>
              <div>
                <dt>Unchanged</dt>
                <dd>${unchangedCount}</dd>
              </div>
            </dl>
          </div>
        `;

        const toNumber = (value) => {
          const coerced = Number(value);
          return Number.isFinite(coerced) ? coerced : null;
        };

        const formatCompareRank = (value) => {
          if (value === null || typeof value === 'undefined') {
            return '—';
          }
          return Number.isFinite(value) ? value : '—';
        };

        const formatCompareCount = (value) => {
          if (value === null || typeof value === 'undefined') {
            return '—';
          }
          return Number.isFinite(value) ? value.toLocaleString() : '—';
        };

        const formatSignedValue = (value) => {
          if (!Number.isFinite(value)) {
            return '—';
          }
          const sign = value > 0 ? '+' : '';
          return `${sign}${value.toLocaleString()}`;
        };

        const formatPositionChange = (rankA, rankB) => {
          if (!Number.isFinite(rankA) || !Number.isFinite(rankB)) {
            return { text: '—', className: 'delta-neutral' };
          }
          const delta = rankB - rankA;
          if (delta > 0) {
            return { text: `↑ ${Math.abs(delta)}`, className: 'delta-up' };
          }
          if (delta < 0) {
            return { text: `↓ ${Math.abs(delta)}`, className: 'delta-down' };
          }
          return { text: '—', className: 'delta-neutral' };
        };

        const getScanTimestamp = (scan) => {
          const rawTimestamp = scan?.created_at || scan?.started_at || scan?.finished_at;
          const parsed = rawTimestamp ? Date.parse(rawTimestamp) : Number.NaN;
          return Number.isFinite(parsed) ? parsed : null;
        };

        const renderHistoryComparison = (scanA, scanB) => {
          if (!historyCompareElements.summary || !historyCompareElements.body) {
            return;
          }
          const followerA = toNumber(scanA?.follower_snapshot);
          const followerB = toNumber(scanB?.follower_snapshot);
          const followerChange =
            Number.isFinite(followerA) && Number.isFinite(followerB)
              ? followerA - followerB
              : null;

          const comparisonMap = new Map();
          const ingestSummary = (scan, label) => {
            const summary = Array.isArray(scan?.summary) ? scan.summary : [];
            summary.forEach((entry) => {
              const countryCode = entry?.country || '—';
              const keyword = entry?.keyword || '—';
              const key = `${countryCode}|||${keyword}`;
              if (!comparisonMap.has(key)) {
                comparisonMap.set(key, { country: countryCode, keyword });
              }
              const row = comparisonMap.get(key);
              row[`rank${label}`] = entry?.tracked_rank ?? null;
            });
          };
          ingestSummary(scanA, 'A');
          ingestSummary(scanB, 'B');

          const rows = Array.from(comparisonMap.values()).sort((first, second) => {
            const countryA = resolveMarketLabel(first.country) || '';
            const countryB = resolveMarketLabel(second.country) || '';
            if (countryA !== countryB) {
              return countryA.localeCompare(countryB);
            }
            return (first.keyword || '').localeCompare(second.keyword || '');
          });

          historyCompareElements.body.innerHTML = '';
          let improvedCount = 0;
          let worsenedCount = 0;
          let unchangedCount = 0;

          rows.forEach((row) => {
            const rankA = Number.isFinite(row.rankA) ? row.rankA : null;
            const rankB = Number.isFinite(row.rankB) ? row.rankB : null;
            if (Number.isFinite(rankA) && Number.isFinite(rankB)) {
              const delta = rankB - rankA;
              if (delta > 0) {
                improvedCount += 1;
              } else if (delta < 0) {
                worsenedCount += 1;
              } else {
                unchangedCount += 1;
              }
            }
          });

          historyCompareElements.summary.innerHTML = `
            ${renderCompareOverviewCard({
              followersChange: formatSignedValue(followerChange),
              improvedCount,
              worsenedCount,
              unchangedCount,
            })}
            ${renderCompareSummaryCard(scanA, 'Scan A (newer)')}
            ${renderCompareSummaryCard(scanB, 'Scan B (older)')}
          `;

          if (historyCompareElements.followersBody) {
            historyCompareElements.followersBody.innerHTML = `
              <tr>
                <td>Followers</td>
                <td>${formatCompareCount(followerA)}</td>
                <td>${formatCompareCount(followerB)}</td>
                <td>${formatSignedValue(followerChange)}</td>
              </tr>
            `;
          }
          if (historyCompareElements.followers) {
            historyCompareElements.followers.hidden = false;
          }
          if (!rows.length) {
            setHistoryCompareMessage('No summary data available to compare.');
            if (historyCompareElements.table) {
              historyCompareElements.table.hidden = true;
            }
            return;
          }

          rows.forEach((row) => {
            const rankA = Number.isFinite(row.rankA) ? row.rankA : null;
            const rankB = Number.isFinite(row.rankB) ? row.rankB : null;
            const positionChange = formatPositionChange(rankA, rankB);
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${resolveMarketLabel(row.country) || '—'}</td>
              <td>${row.keyword || '—'}</td>
              <td>${formatCompareRank(rankA)}</td>
              <td>${formatCompareRank(rankB)}</td>
              <td class="${positionChange.className}">${positionChange.text}</td>
            `;
            historyCompareElements.body.appendChild(tr);
          });

          if (historyCompareElements.table) {
            historyCompareElements.table.hidden = false;
          }
        };

        resetHistoryDetail = ({ skipScroll = false, scrollTarget = null } = {}) => {
          selectedHistoryScanId = null;
          historyDetailRequestId += 1;
          setHistoryDetailMessage('');
          clearHistoryDetailResults();
          hideHistoryDetailPanel();
          if (historyElements.list) {
            showSection(historyElements.list);
          }
          if (!skipScroll) {
            scrollSectionToCenter(scrollTarget || scanHistorySection || historyRoot);
          }
        };

        resetHistoryCompare = ({ skipScroll = false } = {}) => {
          setCompareMode(false, { skipScroll });
        };

        const connectEventStream = (scanId) => {
          if (!scanId) {
            return;
          }
          activeScanId = scanId;
          activeScanStatus = activeScanStatus || 'running';
          syncEtaTicker();
          setStopButtonVisible(true);
          if (eventSource) {
            eventSource.close();
          }
          const eventsUrl = `/api/basic-rank-checker/scans/${scanId}/events`;
          eventSource = new EventSource(eventsUrl);
          startWatchdog();
          startCompletionPoll(scanId);
          eventSource.onmessage = async (event) => {
            try {
              updateLastMessageAt();
              const rawText = event?.data ?? '';
              let payload = null;
              try {
                payload = JSON.parse(rawText);
              } catch (error) {
                payload = null;
              }
              if (payload?.type === 'completed' || payload?.type === 'scan_completed') {
                await safeStop('completed', {
                  scanId: activeScanId,
                  total: payload?.total,
                  switchReason: 'terminal_event',
                });
                return;
              }
              if (payload?.type === 'cancelled') {
                await safeStop('cancelled', { scanId: activeScanId });
                return;
              }
              if (payload?.type === 'progress') {
                activeScanStatus = 'running';
                syncEtaTicker();
                setProgress(payload.step, payload.total, payload.message, payload);
                appendLog(payload.message);
              }
              if (payload?.type === 'error' || payload?.type === 'failed') {
                appendLog(payload.message || 'Scan failed.');
                await safeStop('scan failed');
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.error) {
                console.error('[basic-scan] event handling failed', error);
              }
              await safeStop('handler error');
            }
          };
          eventSource.onerror = (error) => {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] connection error', error);
            }
            safeStop('connection error');
          };
        };

        const resolveTrackedPlaylistId = () => {
          const datasetId = scanRoot?.dataset?.trackedPlaylistId;
          const latestDatasetId = latestRoot?.dataset?.trackedPlaylistId;
          if (datasetId) {
            return datasetId;
          }
          if (latestDatasetId) {
            return latestDatasetId;
          }
          const pathId = window.location.pathname.split('/').filter(Boolean).pop();
          if (!pathId && typeof console !== 'undefined' && console.debug) {
            console.debug('[basic-scan] tracked playlist id missing for payload');
          }
          return pathId || '';
        };

        const cancelActiveScan = async () => {
          if (!activeScanId) {
            return;
          }
          const scanId = activeScanId;
          const cancelPromise = fetch(
            `/api/basic-rank-checker/scans/${scanId}/cancel`,
            { method: 'POST' }
          ).catch(() => null);
          await safeStop('cancelled', { scanId });
          await cancelPromise;
        };

        const fetchActiveScan = async ({ trackedPlaylistId } = {}) => {
          const playlistId = trackedPlaylistId ?? resolveTrackedPlaylistId();
          const url = new URL('/api/basic-rank-checker/scans/active', window.location.origin);
          if (playlistId) {
            url.searchParams.set('tracked_playlist_id', playlistId);
          }
          const response = await fetch(`${url.pathname}${url.search}`);
          const data = await readErrorPayload(response);
          if (response.status === 404) {
            return null;
          }
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load active scan.'));
          }
          return data;
        };

        const resumeActiveScan = (activeScan) => {
          if (!activeScan?.scan_id) {
            return;
          }
          activeScanId = activeScan.scan_id;
          activeScanStatus = activeScan.status || 'running';
          syncEtaTicker();
          setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          openBasicScanStage2();
          applyProgressSnapshot(activeScan.progress, 'Scan in progress...');
          setStopButtonVisible(true);
          connectEventStream(activeScan.scan_id);
        };

        const startScan = async ({ source } = {}) => {
          const trackedPlaylistId = resolveTrackedPlaylistId();
          if (source !== 'button_click') {
            if (typeof console !== 'undefined' && console.warn) {
              console.warn('[START_SCAN_BLOCKED]', { source });
            }
            return;
          }
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[START_SCAN_CALLED] source=button_click', { trackedPlaylistId });
          }
          if (!runButton) {
            return;
          }

          const activeScan = await fetchActiveScan({ trackedPlaylistId }).catch(() => null);
          if (activeScan?.scan_id) {
            if (typeof console !== 'undefined' && console.debug) {
              console.debug('[START_SCAN_SKIPPED] active scan already running', {
                scanId: activeScan.scan_id,
                trackedPlaylistId,
              });
            }
            resumeActiveScan(activeScan);
            setStatus('A scan is already running for this playlist. Resuming…', 'status-loading');
            return;
          }

          hasStopped = false;
          runButton.disabled = true;
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          lastProgressSnapshot = null;
          setEtaMsFromServer(null);
          setStopButtonVisible(true);
          setProgress(0, 0, 'Starting scan…');
          let scanStarted = false;

          try {
            const response = await fetch('/api/basic-rank-checker/scans', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tracked_playlist_id: trackedPlaylistId }),
            });
            const data = await readErrorPayload(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to start scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to start scan.');
            }
            activeScanId = data.scan_id;
            scanStarted = Boolean(activeScanId);
            activeScanStatus = 'running';
            syncEtaTicker();
            connectEventStream(activeScanId);
            setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] start failed', error);
            }
            setStage(1);
            runButton.disabled = false;
            setStopButtonVisible(false);
            setStatus(normalizeErrorMessage(error, 'Failed to start scan.'), 'status-error');
          } finally {
            if (!scanStarted && runButton.disabled) {
              runButton.disabled = false;
              if (basicScanStageController?.getStage?.() === 2) {
                setStage(1);
              }
            }
          }
        };

        loadLatestScan = async () => {
          if (!latestRoot) {
            return;
          }
          const trackedPlaylistId = resolveTrackedPlaylistId();

          try {
            const url = new URL(
              '/api/basic-rank-checker/scans/latest-completed',
              window.location.origin
            );
            if (trackedPlaylistId) {
              url.searchParams.set('tracked_playlist_id', trackedPlaylistId);
            }
            const response = await fetch(`${url.pathname}${url.search}`);
            const data = await readErrorPayload(response);
            if (response.status === 404) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to load latest scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to load latest scan.');
            }
            const resultsPayload = data.results || {};
            if (!hasResults(resultsPayload)) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            renderScanResults(resultsPayload, latestResults, data.scan_id);
          } catch (error) {
            setStatus(normalizeErrorMessage(error, 'Failed to load latest scan.'), 'status-error');
          }
        };

        const formatScanHistoryStatus = (value) => {
          if (!value) {
            return '—';
          }
          return String(value).replace(/_/g, ' ');
        };

        const fetchScanDetail = async (scanId) => {
          if (!scanId) {
            return null;
          }
          const response = await fetch(`/api/basic-rank-checker/scans/${scanId}`);
          const data = await readErrorPayload(response);
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load scan details.'));
          }
          return data;
        };

        const openHistoryDetail = async (scanId) => {
          if (!scanId || !historyDetailPanel) {
            return;
          }
          selectedHistoryScanId = scanId;
          historyDetailRequestId += 1;
          const requestId = historyDetailRequestId;
          if (historyElements.list) {
            hideSection(historyElements.list);
          }
          showHistoryDetailPanel();
          clearHistoryDetailResults();
          setHistoryDetailMessage('Loading scan details…');
          historyDetailPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });

          try {
            const data = await fetchScanDetail(scanId);
            if (requestId !== historyDetailRequestId) {
              return;
            }
            const resultsPayload = data?.results || data;
            if (!resultsPayload || !hasResults(resultsPayload)) {
              showEmptyState(
                historyDetailElements,
                'No scan results were found for this run.'
              );
              setHistoryDetailMessage('No scan results found for this run.');
              return;
            }
            renderScanResults(resultsPayload, historyDetailElements, data?.scan_id || scanId);
            setHistoryDetailMessage('');
          } catch (error) {
            if (requestId !== historyDetailRequestId) {
              return;
            }
            setHistoryDetailMessage(
              normalizeErrorMessage(error, 'Unable to load scan details.'),
              { isError: true }
            );
          }
        };

        const openHistoryCompare = async () => {
          if (selectedCompareScanIds.length !== 2) {
            return;
          }
          compareLoading = true;
          compareError = null;
          compareRequestId += 1;
          const requestId = compareRequestId;
          updateCompareControls();
          if (historyElements.list) {
            hideSection(historyElements.list);
          }
          hideHistoryDetailPanel();
          showHistoryComparePanel();
          clearHistoryCompareResults();
          setHistoryCompareMessage('Loading comparison results…');
          if (historyCompareElements.panel) {
            historyCompareElements.panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }

          try {
            const [firstScan, secondScan] = await Promise.all(
              selectedCompareScanIds.map((scanId) => fetchScanDetail(scanId))
            );
            if (requestId !== compareRequestId) {
              return;
            }
            const firstTimestamp = getScanTimestamp(firstScan);
            const secondTimestamp = getScanTimestamp(secondScan);
            let scanA = firstScan;
            let scanB = secondScan;
            if (firstTimestamp === null && secondTimestamp !== null) {
              scanA = secondScan;
              scanB = firstScan;
            } else if (
              firstTimestamp !== null &&
              secondTimestamp !== null &&
              firstTimestamp < secondTimestamp
            ) {
              scanA = secondScan;
              scanB = firstScan;
            }
            compareData = { scanA, scanB };
            renderHistoryComparison(scanA, scanB);
            setHistoryCompareMessage('');
          } catch (error) {
            if (requestId !== compareRequestId) {
              return;
            }
            compareError = error;
            setHistoryCompareMessage(
              normalizeErrorMessage(error, 'Unable to load comparison results.'),
              { isError: true }
            );
          } finally {
            if (requestId === compareRequestId) {
              compareLoading = false;
              updateCompareControls();
              applyCompareSelectionState();
            }
          }
        };

        const renderScanHistory = (items) => {
          if (!historyElements.body || !historyElements.table || !historyElements.empty) {
            return;
          }
          latestHistoryItems = Array.isArray(items) ? items : [];
          historyElements.body.innerHTML = '';
          if (!latestHistoryItems.length) {
            selectedCompareScanIds = [];
            updateCompareControls();
            historyElements.empty.textContent = 'No scan history yet for this playlist.';
            showSection(historyElements.empty);
            hideSection(historyElements.table);
            return;
          }
          hideSection(historyElements.empty);
          showSection(historyElements.table);
          if (historyCompareElements.column) {
            historyCompareElements.column.hidden = !compareMode;
          }
          latestHistoryItems.forEach((item) => {
            const row = document.createElement('tr');
            const countries = (item.countries || [])
              .map((country) => resolveMarketLabel(country))
              .join(', ');
            const keywords = (item.keywords || []).join(', ');
            const scanDate = formatTimestamp(item.created_at || item.started_at || item.finished_at);
            const scanId = item.scan_id;
            row.classList.add('scan-history-row');
            if (compareMode) {
              row.classList.add('is-disabled');
            }
            row.dataset.scanId = scanId || '';
            if (!compareMode) {
              row.setAttribute('role', 'button');
              row.tabIndex = 0;
            }
            const compareCell = compareMode
              ? `
                <td class="scan-history-compare-cell">
                  <input
                    type="checkbox"
                    class="scan-history-checkbox"
                    data-scan-history-checkbox
                    value="${scanId || ''}"
                  />
                </td>
              `
              : '';
            row.innerHTML = `
              <td>${scanDate}</td>
              <td>${countries || '—'}</td>
              <td>${keywords || '—'}</td>
              ${compareCell}
              <td>${formatScanHistoryStatus(item.status)}</td>
            `;
            if (compareMode) {
              const checkbox = row.querySelector('[data-scan-history-checkbox]');
              if (checkbox) {
                checkbox.addEventListener('change', (event) => {
                  if (!scanId) {
                    event.target.checked = false;
                    return;
                  }
                  const isChecked = event.target.checked;
                  const alreadySelected = selectedCompareScanIds.includes(scanId);
                  if (isChecked) {
                    if (alreadySelected) {
                      return;
                    }
                    if (selectedCompareScanIds.length >= 2) {
                      event.target.checked = false;
                      return;
                    }
                    selectedCompareScanIds = [...selectedCompareScanIds, scanId];
                  } else {
                    selectedCompareScanIds = selectedCompareScanIds.filter(
                      (value) => value !== scanId
                    );
                  }
                  updateCompareControls();
                  applyCompareSelectionState();
                });
              }
            } else {
              const activateRow = () => {
                if (!scanId || compareMode) {
                  return;
                }
                openHistoryDetail(scanId);
              };
              row.addEventListener('click', activateRow);
              row.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  activateRow();
                }
              });
            }
            historyElements.body.appendChild(row);
          });
          applyCompareSelectionState();
        };

        loadScanHistory = async () => {
          if (!historyRoot) {
            return;
          }
          const trackedPlaylistId = resolveTrackedPlaylistId();
          if (!trackedPlaylistId) {
            renderScanHistory([]);
            return;
          }
          try {
            const url = new URL('/api/basic-rank-checker/scans/history', window.location.origin);
            url.searchParams.set('tracked_playlist_id', trackedPlaylistId);
            const response = await fetch(`${url.pathname}${url.search}`);
            const data = await readErrorPayload(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to load scan history.'));
            }
            const items = Array.isArray(data?.items) ? data.items : [];
            const trackedItems = items.filter((item) => item?.is_tracked_playlist);
            renderScanHistory(trackedItems);
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[scan-history] load failed', error);
            }
            setStatus(
              normalizeErrorMessage(error, 'Failed to load scan history.'),
              'status-error'
            );
          }
        };

        historyDetailBackButton?.addEventListener('click', (event) => {
          event.preventDefault();
          resetHistoryDetail({ scrollTarget: historyRoot || scanHistorySection });
        });

        historyCompareElements.toggle?.addEventListener('click', (event) => {
          event.preventDefault();
          if (compareMode) {
            return;
          }
          setCompareMode(true, { skipScroll: true });
        });

        historyCompareElements.cancel?.addEventListener('click', (event) => {
          event.preventDefault();
          resetHistoryCompare({ skipScroll: true });
        });

        historyCompareElements.run?.addEventListener('click', (event) => {
          event.preventDefault();
          if (historyCompareElements.run?.disabled) {
            return;
          }
          openHistoryCompare();
        });

        historyCompareElements.back?.addEventListener('click', (event) => {
          event.preventDefault();
          resetHistoryCompare({ skipScroll: true });
        });

        runButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[UI_START_SCAN_CLICK] Run Dedicated Scan clicked', {
              trackedPlaylistId: resolveTrackedPlaylistId(),
            });
          }
          setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          openBasicScanStage2();
          startScan({ source: 'button_click' });
        });

        basicScanStageController.openBasicScanStage1 = openBasicScanStage1;
        basicScanStageController.openBasicScanStage2 = openBasicScanStage2;

        const initializeScanSections = async () => {
          try {
            const activeScan = await fetchActiveScan();
            if (activeScan?.scan_id) {
              resumeActiveScan(activeScan);
              return;
            }
          } catch (error) {
            setStatus(normalizeErrorMessage(error, 'Failed to load scan status.'), 'status-error');
          }
          logSwitchLatest('none', 'no_active_scan');
          setStopButtonVisible(false);
          setActiveSection('latest', { skipScroll: true });
        };

        initializeScanSections();

        stopButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          cancelActiveScan();
        });
      };

      setupBasicScan();
    </script>
  </body>
</html>
