<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ playlist.name }} · Tracked Playlist</title>
    <link rel="stylesheet" href="/static/ui.css?v={{ build_id }}" />
    <link rel="stylesheet" href="/static/tracked.css?v={{ build_id }}" />
  </head>
  <body class="app-body">
    <main class="page">
      <header class="page-header">
        <div>
          <h1 class="page-title dashboard-title" title="{{ playlist.dashboard_header_title }}">
            <span class="dashboard-title-prefix">Dashboard</span>
          </h1>
        </div>
        <div class="page-header-actions">
          <button class="btn btn-tracked-outline dashboard-action-btn" type="button">Tracked Playlist</button>
          <button class="btn btn-primary dashboard-action-btn" type="button" data-refresh-stats>Refresh Stats</button>
          {% set label = 'Back To Tracked Playlists' %}
          {% set button_variant = 'ghost' %}
          {% set href = '/' %}
          {% set extra_class = 'btn-back-blue dashboard-action-btn' %}
          {% include "_components/button.html" %}
        </div>
      </header>

      <section class="ui-card status-card">
        <div class="status-card-header">
          <h2>Status</h2>
          <p class="status-card-subtitle">Live feedback for playlist actions.</p>
        </div>
        <div id="playlist-status" class="status-area" role="status" aria-live="polite">
          Ready to refresh playlist metadata.
        </div>
      </section>

      <div class="tracked-detail-stack">
        {% set variant = 'detail' %}
        {% include "_components/tracked_card.html" %}

        <section class="toolbar-panel">
          <div class="toolbar-actions">
            <button
              class="btn btn-secondary"
              type="button"
              data-scan-tab="dedicated"
              aria-pressed="true"
            >
              Dedicated Scan
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              data-scan-tab="latest"
              aria-pressed="false"
            >
              Latest Scan Results
            </button>
          </div>
        </section>

        <section class="panel basic-scan-panel is-active" id="basic-scan-section">
          <div class="panel-header">
            <h2>Dedicated Scan</h2>
            <p>Run a manual scan using stored targets.</p>
          </div>
          <div class="panel-body">
            <div class="basic-scan" data-basic-scan data-tracked-playlist-id="{{ playlist.id }}">
              <section class="scan-parameters" id="scan-parameters" data-basic-scan-parameters>
                <div class="scan-config-row">
                  <span class="scan-config-label">Countries</span>
                  <div class="pill-list" data-basic-scan-countries>
                    {% if playlist.target_countries %}
                      {% for country in playlist.target_countries %}
                        {% set label = playlist.target_country_labels.get(country|upper, country) %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ label }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target countries</span>
                    {% endif %}
                  </div>
                </div>
                <div class="scan-config-row">
                  <span class="scan-config-label">Keywords</span>
                  <div class="pill-list" data-basic-scan-keywords>
                    {% if playlist.target_keywords %}
                      {% for keyword in playlist.target_keywords %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ keyword }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target keywords</span>
                    {% endif %}
                  </div>
                </div>
                <div class="run-scan-controls" id="run-scan-controls" data-basic-scan-run-controls>
                  <button class="btn btn-primary" type="button" data-basic-scan-run>Run Basic Scan</button>
                </div>
              </section>
              <section
                class="run-progress basic-scan-progress"
                id="basic-scan-progress"
                data-basic-scan-progress
                hidden
              >
                <div class="progress-bar">
                  <div class="progress-fill" data-basic-scan-progress-fill></div>
                </div>
                <div class="progress-status" data-basic-scan-progress-status>Starting scan…</div>
                <div class="progress-eta" data-basic-scan-progress-eta>
                  Estimated remaining time: Estimating…
                </div>
                <div class="progress-log" data-basic-scan-progress-log></div>
              </section>
              {% set results_id = 'basic-scan-results' %}
              {% set results_title = 'Basic Scan Results' %}
              {% set data_prefix = 'basic-scan' %}
              {% set csv_controls_id = 'basic-scan-csv-controls' %}
              {% set summary_id = 'basic-scan-summary' %}
              {% set detailed_id = 'basic-scan-detailed' %}
              {% include "_components/scan_results.html" %}
            </div>
          </div>
        </section>

        <section class="panel latest-scan-panel is-hidden" id="latest-scan-section">
          <div class="panel-header">
            <h2>Latest Scan Results</h2>
            <p>Most recent completed scan, refreshed on every visit.</p>
          </div>
          <div class="panel-body">
            <div class="latest-scan" data-latest-scan data-tracked-playlist-id="{{ playlist.id }}">
              {% set results_id = 'latest-scan-results' %}
              {% set results_title = 'Latest Scan Results' %}
              {% set data_prefix = 'latest-scan' %}
              {% set csv_controls_id = 'latest-scan-csv-controls' %}
              {% set summary_id = 'latest-scan-summary' %}
              {% set detailed_id = 'latest-scan-detailed' %}
              {% include "_components/scan_results.html" %}
            </div>
          </div>
        </section>
      </div>
    </main>

    <script>
      const statusArea = document.getElementById('playlist-status');
      const refreshButton = document.querySelector('[data-refresh-stats]');
      const playlistDetailRoot = document.querySelector('[data-tracked-card][data-playlist-id]');
      const playlistId = playlistDetailRoot?.dataset.playlistId || null;
      const ownerValue = playlistDetailRoot?.querySelector('[data-playlist-owner]') || null;
      const followersValue = playlistDetailRoot?.querySelector('[data-playlist-followers]') || null;
      const tracksValue = playlistDetailRoot?.querySelector('[data-playlist-tracks]') || null;
      const scannedValue = playlistDetailRoot?.querySelector('[data-playlist-scanned]') || null;
      const updatedValue = playlistDetailRoot?.querySelector('[data-playlist-updated]') || null;
      const toolbarButtons = document.querySelectorAll('[data-panel-target]');
      const panels = document.querySelectorAll('.panel[data-panel]');
      const toolbar = document.querySelector('.toolbar-panel');
      let lastAnchor = toolbar;
      const basicScanSection = document.getElementById('basic-scan-section');
      const latestScanSection = document.getElementById('latest-scan-section');
      const scanTabButtons = document.querySelectorAll('[data-scan-tab]');
      let basicScanStageController = null;
      let activeScanTab = null;
      let loadLatestScan = null;
      let lastTabScrollY = null;

      const togglePanel = (targetId) => {
        let activePanel = null;
        panels.forEach((panel) => {
          if (panel.id === targetId) {
            activePanel = panel;
          }
        });

        if (!activePanel) {
          return;
        }

        const isActive = activePanel.classList.contains('is-active');
        panels.forEach((panel) => panel.classList.remove('is-active'));

        if (!isActive) {
          lastAnchor = toolbar || document.body;
          activePanel.classList.add('is-active');
          activePanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          return;
        }

        if (lastAnchor) {
          lastAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      toolbarButtons.forEach((button) => {
        button.addEventListener('click', () => {
          togglePanel(button.dataset.panelTarget);
        });
      });

      if (panels.length) {
        panels[0].classList.add('is-active');
      }

      const showSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = false;
        section.style.removeProperty('display');
      };

      const hideSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = true;
        section.style.display = 'none';
      };

      const scrollSectionToCenter = (section) => {
        if (!section) {
          return;
        }
        const rect = section.getBoundingClientRect();
        const sectionTop = window.scrollY + rect.top;
        const target =
          sectionTop - window.innerHeight / 2 + rect.height / 2;
        window.scrollTo({ top: Math.max(target, 0), behavior: 'smooth' });
      };

      const setActiveScanTab = (nextTab, options = {}) => {
        if (!nextTab || nextTab === activeScanTab) {
          return;
        }
        lastTabScrollY = window.scrollY;
        activeScanTab = nextTab;

        if (nextTab === 'dedicated') {
          basicScanSection?.classList.add('is-active');
          latestScanSection?.classList.remove('is-active');
          basicScanSection?.classList.remove('is-hidden');
          latestScanSection?.classList.add('is-hidden');
          if (basicScanStageController) {
            basicScanStageController.setStage(basicScanStageController.getStage());
          }
        } else {
          latestScanSection?.classList.add('is-active');
          basicScanSection?.classList.remove('is-active');
          latestScanSection?.classList.remove('is-hidden');
          basicScanSection?.classList.add('is-hidden');
        }

        scanTabButtons.forEach((button) => {
          const isActive = button.dataset.scanTab === activeScanTab;
          button.setAttribute('aria-pressed', String(isActive));
          button.classList.toggle('is-active', isActive);
        });

        if (nextTab === 'latest' && !options.skipFetch && typeof loadLatestScan === 'function') {
          loadLatestScan();
        }

        if (!options.skipScroll && lastTabScrollY !== null) {
          window.scrollTo({ top: lastTabScrollY, behavior: 'smooth' });
        }
      };

      scanTabButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          const nextTab = button.dataset.scanTab;
          setActiveScanTab(nextTab);
        });
      });

      const setStatus = (message, variant) => {
        if (!statusArea) {
          return;
        }
        statusArea.textContent = message;
        statusArea.classList.remove('status-success', 'status-error', 'status-loading');
        if (variant) {
          statusArea.classList.add(variant);
        }
      };

      const readErrorPayload = async (response) => {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          try {
            return await response.json();
          } catch (error) {
            return null;
          }
        }
        try {
          const text = await response.text();
          return text || null;
        } catch (error) {
          return null;
        }
      };

      const parseJsonSafely = async (response) => {
        try {
          return await response.json();
        } catch (error) {
          return null;
        }
      };

      const normalizeErrorMessage = (payload, fallback) => {
        if (!payload) {
          return fallback;
        }
        if (typeof payload === 'string') {
          return payload;
        }
        const detail = payload.detail ?? payload.message ?? payload.error ?? payload;
        if (typeof detail === 'string') {
          return detail;
        }
        try {
          return JSON.stringify(detail);
        } catch (error) {
          return fallback;
        }
      };

      const formatFollowersValue = (value) => {
        if (value === undefined || value === null || value === '') {
          return '—';
        }
        if (typeof value === 'object') {
          if ('total' in value) {
            return formatFollowersValue(value.total);
          }
          return '—';
        }
        const numeric = Number(value);
        if (Number.isFinite(numeric)) {
          return numeric.toLocaleString();
        }
        return value;
      };

      const formatRelativeTime = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '—';
        }
        const deltaSeconds = Math.max(0, Math.floor((Date.now() - date.getTime()) / 1000));
        if (deltaSeconds < 60) {
          return 'just now';
        }
        const minutes = Math.floor(deltaSeconds / 60);
        if (minutes < 60) {
          return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} ago`;
        }
        const hours = Math.floor(minutes / 60);
        if (hours < 24) {
          return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`;
        }
        const days = Math.floor(hours / 24);
        return `${days} ${days === 1 ? 'day' : 'days'} ago`;
      };

      const captureDomSnapshot = () => ({
        owner: ownerValue?.textContent?.trim() || '',
        followers: followersValue?.textContent?.trim() || '',
        tracks: tracksValue?.textContent?.trim() || '',
        scanned: scannedValue?.textContent?.trim() || '',
        updated: updatedValue?.textContent?.trim() || '',
      });

      const buildDataSnapshot = (data) => ({
        owner: data?.owner_name || '—',
        followers: formatFollowersValue(data?.followers_total),
        tracks: formatFollowersValue(data?.tracks_count),
        scanned: formatRelativeTime(data?.stats_updated_at),
        updated: formatRelativeTime(data?.playlist_last_updated_at),
      });

      const snapshotsDiffer = (next, baseline) =>
        Object.keys(baseline || {}).some((key) => (next?.[key] || '') !== (baseline?.[key] || ''));

      const applyPlaylistData = (data) => {
        if (!data) {
          return;
        }
        if (ownerValue) {
          ownerValue.textContent = data.owner_name || '—';
        }
        if (followersValue) {
          followersValue.textContent = formatFollowersValue(data.followers_total);
        }
        if (tracksValue) {
          tracksValue.textContent = formatFollowersValue(data.tracks_count);
        }
        if (scannedValue) {
          scannedValue.textContent = formatRelativeTime(data.stats_updated_at);
        }
        if (updatedValue) {
          updatedValue.textContent = formatRelativeTime(data.playlist_last_updated_at);
        }
      };

      const fetchPlaylistDetail = async () => {
        if (!playlistId) {
          return null;
        }
        const response = await fetch('/api/playlists');
        if (!response.ok) {
          return null;
        }
        const payload = await parseJsonSafely(response);
        if (!Array.isArray(payload)) {
          return null;
        }
        return payload.find((item) => String(item.id) === String(playlistId)) || null;
      };

      const pollForPlaylistUpdate = async (baselineSnapshot, baselineRefreshAt) => {
        const POLL_INTERVAL_MS = 2000;
        const MAX_ATTEMPTS = 30;
        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
          try {
            const data = await fetchPlaylistDetail();
            if (data) {
              const currentSnapshot = buildDataSnapshot(data);
              const refreshAt = data.last_meta_refresh_at || null;
              if (
                snapshotsDiffer(currentSnapshot, baselineSnapshot) ||
                (baselineRefreshAt && refreshAt && refreshAt !== baselineRefreshAt)
              ) {
                applyPlaylistData(data);
                return { updated: true, data };
              }
            }
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[ui] refresh stats polling failed', error);
            }
          }
          await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL_MS));
        }
        return { updated: false, data: null };
      };

      refreshButton?.addEventListener('click', async () => {
        if (!refreshButton || !playlistDetailRoot || !playlistId) {
          return;
        }
        refreshButton.disabled = true;
        setStatus('Fetching data from Spotify… please wait', 'status-loading');
        let didUpdate = false;
        let baselineSnapshot = captureDomSnapshot();
        let baselineRefreshAt = null;

        try {
          const preRefreshData = await fetchPlaylistDetail();
          if (preRefreshData) {
            baselineSnapshot = buildDataSnapshot(preRefreshData);
            baselineRefreshAt = preRefreshData.last_meta_refresh_at || null;
          }
          const response = await fetch(`/api/playlists/{{ playlist.id }}/refresh-stats`, {
            method: 'POST',
          });
          if (!response.ok) {
            const errorPayload = await readErrorPayload(response);
            const message = normalizeErrorMessage(
              errorPayload,
              'Unable to refresh playlist metadata.'
            );
            setStatus(message, 'status-error');
            return;
          }

          let data = null;
          data = await parseJsonSafely(response);
          const refreshedAt =
            data && typeof data === 'object' && data.refreshed_at ? new Date(data.refreshed_at) : null;
          const queuedAt =
            data && typeof data === 'object' && data.queued_at ? new Date(data.queued_at) : null;
          if (refreshedAt) {
            const timeLabel = refreshedAt.toLocaleString();
            setStatus(`✅ Playlist metadata refreshed at ${timeLabel}`, 'status-success');
          } else {
            const queuedLabel = queuedAt ? queuedAt.toLocaleString() : 'just now';
            const statusLabel =
              data && typeof data === 'object' && data.status === 'already_running'
                ? 'Already running'
                : 'Queued';
            setStatus(`⏳ ${statusLabel}: refresh scheduled at ${queuedLabel}.`, 'status-success');
          }

          const pollResult = await pollForPlaylistUpdate(baselineSnapshot, baselineRefreshAt);
          if (pollResult.updated) {
            didUpdate = true;
            setStatus('✅ Playlist stats updated.', 'status-success');
          } else {
            setStatus(
              'Refresh completed, but UI update timed out. Please reload.',
              'status-error'
            );
          }
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[ui] refresh stats failed', error);
          }
          const message = normalizeErrorMessage(
            error,
            'Network error while refreshing playlist.'
          );
          setStatus(message, 'status-error');
        } finally {
          refreshButton.disabled = false;
          if (!didUpdate && statusArea?.classList.contains('status-loading')) {
            setStatus('Unable to refresh playlist metadata.', 'status-error');
          }
        }
      });

      const availableMarkets = {{ available_markets | tojson }};
      const marketLabelMap = new Map(
        availableMarkets.map((market) => [market.code.toUpperCase(), market.label])
      );

      const resolveMarketLabel = (code) => marketLabelMap.get((code || '').toUpperCase()) || code;

      const formatTimestamp = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return new Intl.DateTimeFormat('sv-SE', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);
      };

      const formatSummaryDateParts = (value) => {
        if (!value) {
          return { dateLabel: '—', timeLabel: '—' };
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return { dateLabel: value, timeLabel: value };
        }
        const dateLabel = date.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        });
        const timeLabel = date.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
        });
        return { dateLabel, timeLabel };
      };

      const formatFileTimestamp = (value) => {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        const pad = (part) => String(part).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${day}-${month}-${year}_${hours}-${minutes}`;
      };

      const flagEmoji = (code) => {
        const upper = (code || '').toUpperCase();
        if (upper.length !== 2) {
          return '';
        }
        return upper.replace(/./g, (char) => String.fromCodePoint(127397 + char.charCodeAt()));
      };

      const setupBasicScan = () => {
        const scanRoot = document.querySelector('[data-basic-scan]');
        const latestRoot = document.querySelector('[data-latest-scan]');
        if (!scanRoot) {
          return;
        }
        const scanParameters = scanRoot.querySelector('[data-basic-scan-parameters]');
        const runControls = scanRoot.querySelector('[data-basic-scan-run-controls]');
        const runButton = scanRoot.querySelector('[data-basic-scan-run]');
        const progressWrap = scanRoot.querySelector('[data-basic-scan-progress]');
        const progressFill = scanRoot.querySelector('[data-basic-scan-progress-fill]');
        const progressStatus = scanRoot.querySelector('[data-basic-scan-progress-status]');
        const progressEta = scanRoot.querySelector('[data-basic-scan-progress-eta]');
        const progressLog = scanRoot.querySelector('[data-basic-scan-progress-log]');
        const buildScanElements = (prefix, root) => ({
          resultsWrap: root?.querySelector(`[data-${prefix}-results]`),
          summaryLead: root?.querySelector(`[data-${prefix}-summary-lead]`),
          summaryList: root?.querySelector(`[data-${prefix}-summary-list]`),
          detailedWrap: root?.querySelector(`[data-${prefix}-detailed]`),
          exportSummary: root?.querySelector(`[data-${prefix}-export-summary]`),
          exportDetailed: root?.querySelector(`[data-${prefix}-export-detailed]`),
          summarySection: root?.querySelector(`[data-${prefix}-summary-section]`),
          detailedSection: root?.querySelector(`[data-${prefix}-detailed-section]`),
          csvControls: root?.querySelector(`[data-${prefix}-csv-controls]`),
        });
        const basicResults = buildScanElements('basic-scan', scanRoot);
        const latestResults = buildScanElements('latest-scan', latestRoot);
        const resultsWrap = basicResults.resultsWrap;
        const summaryLead = basicResults.summaryLead;
        const summaryList = basicResults.summaryList;
        const detailedWrap = basicResults.detailedWrap;
        const exportSummary = basicResults.exportSummary;
        const exportDetailed = basicResults.exportDetailed;
        const summarySection = basicResults.summarySection;
        const detailedSection = basicResults.detailedSection;
        const csvControls = basicResults.csvControls;
        const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        let activeScanId = null;
        let eventSource = null;
        let currentStage = 1;
        let watchdogTimer = null;
        let lastMessageAt = null;
        let hasStopped = false;
        let pollTimer = null;
        let pollActiveScanId = null;
        let pollInFlight = false;
        let pollStartAt = null;
        const WATCHDOG_MS = 45000;
        const WATCHDOG_CHECK_MS = 5000;

        const setStage = (stage, scrollTarget) => {
          currentStage = stage;
          const showStage1 = stage === 1;
          const showStage2 = stage === 2;
          const showStage3 = stage === 3;

          if (showStage1) {
            showSection(scanParameters);
            showSection(runControls);
            hideSection(progressWrap);
            hideSection(resultsWrap);
            hideSection(csvControls);
          }

          if (showStage2) {
            hideSection(scanParameters);
            hideSection(runControls);
            showSection(progressWrap);
            hideSection(resultsWrap);
            hideSection(csvControls);
          }

          if (showStage3) {
            hideSection(scanParameters);
            hideSection(runControls);
            hideSection(progressWrap);
            showSection(resultsWrap);
            showSection(csvControls);
          }

          const target =
            scrollTarget ||
            (showStage1 ? scanParameters || scanRoot : showStage2 ? progressWrap : summarySection);
          scrollSectionToCenter(target);
        };
        basicScanStageController = { setStage, getStage: () => currentStage };

        const openBasicScanStage1 = () => {
          setStage(1, scanParameters || scanRoot);
        };

        const openBasicScanStage2 = () => {
          setStage(2, progressWrap || scanRoot);
        };

        const formatEta = (progress) => {
          const etaMs = progress?.eta_ms;
          if (Number.isFinite(etaMs) && etaMs !== null) {
            const totalSeconds = Math.max(Math.round(etaMs / 1000), 0);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
          }
          if (progress?.eta_human) {
            return progress.eta_human;
          }
          return null;
        };

        const updateEta = (progress) => {
          if (!progressEta) {
            return;
          }
          const formatted = formatEta(progress);
          progressEta.textContent = `Estimated remaining time: ${formatted || 'Estimating…'}`;
        };

        const buildProgressMessage = (message) => message || 'Scanning...';

        const setProgress = (current, total, message, progress = null) => {
          if (!progressWrap) {
            return;
          }
          const percent = total ? Math.min((current / total) * 100, 100) : 0;
          if (progressFill) {
            progressFill.style.width = `${percent}%`;
          }
          if (progressStatus) {
            progressStatus.textContent = buildProgressMessage(message);
          }
          updateEta(progress);
        };

        const appendLog = (message) => {
          if (!progressLog || !message) {
            return;
          }
          const entry = document.createElement('div');
          entry.className = 'progress-log-entry';
          entry.textContent = message;
          progressLog.appendChild(entry);
          progressLog.scrollTop = progressLog.scrollHeight;
        };

        const hasResults = (scan) => {
          if (!scan || typeof scan !== 'object') {
            return false;
          }
          if (Array.isArray(scan.summary)) {
            return scan.summary.length > 0;
          }
          if (scan.detailed && typeof scan.detailed === 'object') {
            return Object.keys(scan.detailed).length > 0;
          }
          return false;
        };

        const isScanComplete = (scan) =>
          scan?.status === 'completed' ||
          scan?.status === 'completed_partial' ||
          Boolean(scan?.finished_at) ||
          hasResults(scan);

        const applyProgressSnapshot = (progress, messageOverride) => {
          if (!progress || typeof progress !== 'object') {
            return;
          }
          const completed = progress.completed_units ?? 0;
          const total = progress.total_units ?? 0;
          const message = messageOverride || 'Scan in progress...';
          setProgress(completed, total, message, progress);
        };

        const stopPolling = () => {
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
          pollStartAt = null;
          pollActiveScanId = null;
          pollInFlight = false;
        };

        const startCompletionPoll = (scanId) => {
          if (!scanId) {
            return;
          }
          stopPolling();
          pollActiveScanId = scanId;
          pollStartAt = Date.now();
          pollTimer = setInterval(async () => {
            if (!pollActiveScanId || pollInFlight) {
              return;
            }
            if (Date.now() - pollStartAt > 10 * 60 * 1000) {
              stopPolling();
              return;
            }
            pollInFlight = true;
            try {
              const response = await fetch(
                `/api/basic-rank-checker/scans/${pollActiveScanId}`
              );
              const data = await readErrorPayload(response);
              if (!response.ok) {
                throw new Error(
                  normalizeErrorMessage(data, 'Unable to check scan status.')
                );
              }
              if (data?.progress) {
                applyProgressSnapshot(data.progress);
              }
              if (isScanComplete(data)) {
                await safeStop('completed', { scanId: pollActiveScanId });
                stopPolling();
              } else if (data?.status === 'failed') {
                appendLog('Scan failed.');
                await safeStop('scan failed');
                stopPolling();
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.debug) {
                console.debug('[basic-scan] polling error', error);
              }
            } finally {
              pollInFlight = false;
            }
          }, 5000);
        };

        const clearWatchdog = () => {
          if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
          }
          lastMessageAt = null;
        };

        const startWatchdog = () => {
          clearWatchdog();
          lastMessageAt = Date.now();
          watchdogTimer = setInterval(() => {
            if (!lastMessageAt) {
              return;
            }
            if (Date.now() - lastMessageAt > WATCHDOG_MS) {
              safeStop('timeout');
            }
          }, WATCHDOG_CHECK_MS);
        };

        const updateLastMessageAt = () => {
          lastMessageAt = Date.now();
        };

        const safeStop = async (reason, options = {}) => {
          if (hasStopped) {
            return;
          }
          hasStopped = true;
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          clearWatchdog();
          stopPolling();
          if (progressLog) {
            progressLog.innerHTML = '';
          }

          const statusMessages = {
            completed: '✅ Basic Scan completed.',
            timeout: 'Basic Scan timed out. Please try again.',
            'connection error': 'Basic Scan connection lost. Please try again.',
            'handler error': 'Basic Scan failed. Please try again.',
            'scan failed': 'Basic Scan failed. Please try again.',
          };
          const statusMessage = statusMessages[reason] || 'Basic Scan stopped.';
          const variant = reason === 'completed' ? 'status-success' : 'status-error';

          if (reason === 'completed') {
            setProgress(options.total || 1, options.total || 1, 'Scan completed.', { eta_ms: 0 });
            if (options.scanId) {
              try {
                await loadResults(options.scanId);
              } catch (error) {
                setStatus('Failed to load scan results.', 'status-error');
              }
            }
            setStage(3, summarySection);
          } else {
            setProgress(0, 1, statusMessage);
            setStage(1, scanParameters || scanRoot);
          }

          if (runButton) {
            runButton.disabled = false;
          }
          setStatus(statusMessage, variant);
        };

        const renderSummary = (scan, elements) => {
          const summaryLeadEl = elements?.summaryLead;
          const summaryListEl = elements?.summaryList;
          if (!summaryLeadEl || !summaryListEl) {
            return;
          }
          const follower = scan.follower_snapshot ?? '—';
          summaryLeadEl.textContent = `At ${formatTimestamp(
            scan.started_at
          )}, your playlist follower count was ${follower}.`;
          summaryListEl.innerHTML = '';
          (scan.summary || []).forEach((item) => {
            const row = document.createElement('div');
            row.className = `summary-row ${item.tracked_found_in_top20 ? '' : 'summary-row-missing'}`;
            const countryLabel = resolveMarketLabel(item.country);
            const { dateLabel, timeLabel } = formatSummaryDateParts(item.searched_at);
            const rankText = item.tracked_found_in_top20
              ? `your playlist rank was #${item.tracked_rank}.`
              : 'your playlist was not found in the top 20.';
            row.textContent = `On ${dateLabel} at ${timeLabel} in ${countryLabel} for ‘${item.keyword}’, ${rankText}`;
            summaryListEl.appendChild(row);
          });
        };

        const resolveFollowers = (result) => {
          const nestedFollowers =
            result.followers && typeof result.followers === 'object'
              ? result.followers.total
              : undefined;
          const nestedPlaylistFollowers =
            result.playlist && typeof result.playlist === 'object'
              ? result.playlist.followers || result.playlist.followers_total || result.playlist.follower_count
              : undefined;
          const nestedPlaylistFollowersTotal =
            nestedPlaylistFollowers && typeof nestedPlaylistFollowers === 'object'
              ? nestedPlaylistFollowers.total
              : undefined;
          const candidate =
            result.playlist_followers ??
            result.followers_total ??
            result.followers_count ??
            result.follower_count ??
            nestedFollowers ??
            nestedPlaylistFollowersTotal ??
            nestedPlaylistFollowers ??
            result.followers;
          return formatFollowersValue(candidate);
        };

        const renderDetailed = (scan, elements) => {
          const detailedWrapEl = elements?.detailedWrap;
          if (!detailedWrapEl) {
            return;
          }
          detailedWrapEl.innerHTML = '';
          const detailed = scan.detailed || {};
          const countryAccordions = [];
          Object.values(detailed).forEach((countryData) => {
            const countryCode = countryData.country;
            const countryDetails = document.createElement('details');
            countryDetails.className = 'accordion';
            const summary = document.createElement('summary');
            summary.textContent = `${flagEmoji(countryCode)} ${resolveMarketLabel(countryCode)}`;
            countryDetails.addEventListener('toggle', () => {
              if (!countryDetails.open) {
                return;
              }
              countryAccordions.forEach((openDetails) => {
                if (openDetails !== countryDetails) {
                  openDetails.open = false;
                }
              });
              requestAnimationFrame(() => {
                scrollSectionToCenter(countryDetails);
              });
            });
            countryDetails.appendChild(summary);
            countryAccordions.push(countryDetails);

            const keywordContainer = document.createElement('div');
            keywordContainer.className = 'accordion-body';
            const keywordAccordions = [];

            Object.entries(countryData.keywords || {}).forEach(([keyword, keywordData]) => {
              const keywordDetails = document.createElement('details');
              keywordDetails.className = 'accordion nested';
              const keywordSummary = document.createElement('summary');
              keywordSummary.textContent = `${keyword} · ${formatTimestamp(keywordData.searched_at)}`;
              keywordDetails.appendChild(keywordSummary);
              keywordDetails.addEventListener('toggle', () => {
                if (!keywordDetails.open) {
                  return;
                }
                keywordAccordions.forEach((openKeyword) => {
                  if (openKeyword !== keywordDetails) {
                    openKeyword.open = false;
                  }
                });
                requestAnimationFrame(() => {
                  scrollSectionToCenter(keywordDetails);
                });
              });

              const table = document.createElement('table');
              table.className = 'results-table';
              table.innerHTML = `
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Playlist</th>
                    <th>Owner</th>
                    <th>Followers</th>
                    <th>Songs</th>
                  </tr>
                </thead>
                <tbody></tbody>
              `;
              const tbody = table.querySelector('tbody');
              (keywordData.results || []).forEach((result) => {
                const followersValue = resolveFollowers(result);
                const row = document.createElement('tr');
                if (result.is_tracked_playlist) {
                  row.classList.add('tracked-highlight');
                }
                row.innerHTML = `
                  <td>${result.rank ?? '—'}</td>
                  <td>
                    ${
                      result.playlist_url
                        ? `<a href="${result.playlist_url}" target="_blank" rel="noopener noreferrer">${result.playlist_name || '—'}</a>`
                        : result.playlist_name || '—'
                    }
                  </td>
                  <td>${result.playlist_owner || '—'}</td>
                  <td>${followersValue}</td>
                  <td>${result.songs_count ?? '—'}</td>
                `;
                tbody.appendChild(row);
              });

              const tableScroll = document.createElement('div');
              tableScroll.className = 'table-scroll';
              tableScroll.appendChild(table);

              const keywordBody = document.createElement('div');
              keywordBody.className = 'accordion-body';
              keywordBody.appendChild(tableScroll);
              keywordDetails.appendChild(keywordBody);
              keywordContainer.appendChild(keywordDetails);
              keywordAccordions.push(keywordDetails);
            });

            countryDetails.appendChild(keywordContainer);
            detailedWrapEl.appendChild(countryDetails);
          });
        };

        const updateExportLinks = (scanId, startedAt, elements) => {
          const exportSummaryEl = elements?.exportSummary;
          const exportDetailedEl = elements?.exportDetailed;
          const timestamp = formatFileTimestamp(startedAt);
          const effectiveScanId = scanId || 'scan';
          const filenameBase = timestamp
            ? `${timestamp}_${effectiveScanId}`
            : `${effectiveScanId}`;
          const buildExportUrl = (path) => {
            const url = new URL(path, window.location.origin);
            if (timeZone) {
              url.searchParams.set('timezone', timeZone);
            }
            return `${url.pathname}${url.search}`;
          };
          if (exportSummaryEl) {
            exportSummaryEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/summary.csv`
            );
            exportSummaryEl.download = `${filenameBase}_summary.csv`;
          }
          if (exportDetailedEl) {
            exportDetailedEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/detailed.csv`
            );
            exportDetailedEl.download = `${filenameBase}_detailed.csv`;
          }
        };

        const fetchScanResults = async (scanId) => {
          const response = await fetch(`/api/basic-rank-checker/scans/${scanId}`);
          const data = await parseJsonSafely(response);
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load scan results.'));
          }
          if (!data || typeof data !== 'object') {
            throw new Error('Failed to load scan results.');
          }
          return data;
        };

        const renderScanResults = (scan, elements, scanId) => {
          if (!scan || typeof scan !== 'object') {
            return;
          }
          renderSummary(scan, elements);
          renderDetailed(scan, elements);
          if (elements?.summaryList) {
            elements.summaryList.hidden = false;
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = false;
          }
          if (elements?.csvControls) {
            showSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
          const startedAt =
            scan.started_at || scan.searched_at || scan.summary?.[0]?.searched_at;
          updateExportLinks(scanId, startedAt, elements);
        };

        const showEmptyState = (elements, message) => {
          if (elements?.summaryLead) {
            elements.summaryLead.textContent = message;
            elements.summaryLead.hidden = false;
          }
          if (elements?.summaryList) {
            elements.summaryList.innerHTML = '';
            elements.summaryList.hidden = true;
          }
          if (elements?.detailedWrap) {
            elements.detailedWrap.innerHTML = '';
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = true;
          }
          if (elements?.csvControls) {
            hideSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
        };

        const loadResults = async (scanId, elements = basicResults) => {
          const data = await fetchScanResults(scanId);
          renderScanResults(data, elements, data.scan_id || scanId);
        };

        const connectEventStream = (scanId) => {
          if (!scanId) {
            return;
          }
          activeScanId = scanId;
          if (eventSource) {
            eventSource.close();
          }
          const eventsUrl = `/api/basic-rank-checker/scans/${scanId}/events`;
          eventSource = new EventSource(eventsUrl);
          startWatchdog();
          startCompletionPoll(scanId);
          eventSource.onmessage = async (event) => {
            try {
              updateLastMessageAt();
              const rawText = event?.data ?? '';
              let payload = null;
              try {
                payload = JSON.parse(rawText);
              } catch (error) {
                payload = null;
              }
              const statusValue = `${payload?.status ?? payload?.type ?? ''}`.toLowerCase();
              const completionText = rawText.toLowerCase();
              const completionSignals = ['completed', 'done', 'finished'];
              if (
                completionSignals.includes(statusValue) ||
                completionSignals.some((signal) => completionText.includes(signal))
              ) {
                await safeStop('completed', {
                  scanId: activeScanId,
                  total: payload?.total,
                });
                return;
              }
              if (payload?.type === 'progress') {
                setProgress(payload.step, payload.total, payload.message, payload);
                appendLog(payload.message);
              }
              if (payload?.type === 'done') {
                await safeStop('completed', {
                  scanId: activeScanId,
                  total: payload?.total,
                });
              }
              if (payload?.type === 'error') {
                appendLog(payload.message || 'Scan failed.');
                await safeStop('scan failed');
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.error) {
                console.error('[basic-scan] event handling failed', error);
              }
              await safeStop('handler error');
            }
          };
          eventSource.onerror = (error) => {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] connection error', error);
            }
            safeStop('connection error');
          };
        };

        const resolveTrackedPlaylistId = () => {
          const datasetId = scanRoot?.dataset?.trackedPlaylistId;
          const latestDatasetId = latestRoot?.dataset?.trackedPlaylistId;
          if (datasetId) {
            return datasetId;
          }
          if (latestDatasetId) {
            return latestDatasetId;
          }
          const pathId = window.location.pathname.split('/').filter(Boolean).pop();
          if (!pathId && typeof console !== 'undefined' && console.debug) {
            console.debug('[basic-scan] tracked playlist id missing for payload');
          }
          return pathId || '';
        };

        const startScan = async () => {
          const trackedPlaylistId = resolveTrackedPlaylistId();
          if (!runButton) {
            return;
          }
          hasStopped = false;
          runButton.disabled = true;
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          setProgress(0, 0, 'Starting scan…');
          let scanStarted = false;

          try {
            const response = await fetch('/api/basic-rank-checker/scans', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tracked_playlist_id: trackedPlaylistId }),
            });
            const data = await readErrorPayload(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to start scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to start scan.');
            }
            activeScanId = data.scan_id;
            scanStarted = Boolean(activeScanId);
            connectEventStream(activeScanId);
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] start failed', error);
            }
            setStage(1);
            runButton.disabled = false;
            setStatus(normalizeErrorMessage(error, 'Failed to start scan.'), 'status-error');
          } finally {
            if (!scanStarted && runButton.disabled) {
              runButton.disabled = false;
              if (basicScanStageController?.getStage?.() === 2) {
                setStage(1);
              }
            }
          }
        };

        loadLatestScan = async () => {
          if (!latestRoot) {
            return;
          }
          const trackedPlaylistId = resolveTrackedPlaylistId();

          try {
            const url = new URL(
              '/api/basic-rank-checker/scans/latest-completed',
              window.location.origin
            );
            if (trackedPlaylistId) {
              url.searchParams.set('tracked_playlist_id', trackedPlaylistId);
            }
            const response = await fetch(`${url.pathname}${url.search}`);
            const data = await readErrorPayload(response);
            if (response.status === 404) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to load latest scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to load latest scan.');
            }
            const resultsPayload = data.results || {};
            if (!hasResults(resultsPayload)) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            renderScanResults(resultsPayload, latestResults, data.scan_id);
          } catch (error) {
            setStatus(normalizeErrorMessage(error, 'Failed to load latest scan.'), 'status-error');
          }
        };

        runButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          openBasicScanStage2();
          startScan();
        });

        basicScanStageController.openBasicScanStage1 = openBasicScanStage1;
        basicScanStageController.openBasicScanStage2 = openBasicScanStage2;
      };

      setupBasicScan();
      setActiveScanTab('dedicated', { skipScroll: true, skipFetch: true });
    </script>
  </body>
</html>
