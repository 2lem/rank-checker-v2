<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ playlist.name }} · Tracked Playlist</title>
    <link rel="stylesheet" href="/static/ui.css?v={{ build_id }}" />
    <link rel="stylesheet" href="/static/tracked.css?v={{ build_id }}" />
  </head>
  <body class="app-body">
    <main class="page">
      <header class="page-header">
        <div>
          <h1 class="page-title dashboard-title" title="{{ playlist.dashboard_header_title }}">
            <span class="dashboard-title-prefix">Dashboard</span>
          </h1>
        </div>
        <div class="page-header-actions">
          <button class="btn btn-tracked-outline dashboard-action-btn" type="button">Tracked Playlist</button>
          <button class="btn btn-primary dashboard-action-btn" type="button" data-refresh-stats>Refresh Stats</button>
          {% set label = 'Back To Tracked Playlists' %}
          {% set button_variant = 'ghost' %}
          {% set href = '/' %}
          {% set extra_class = 'btn-back-blue dashboard-action-btn' %}
          {% include "_components/button.html" %}
        </div>
      </header>

      <section class="ui-card status-card">
        <div class="status-card-header">
          <h2>Status</h2>
          <p class="status-card-subtitle">Live feedback for playlist actions.</p>
        </div>
        <div id="playlist-status" class="status-area" role="status" aria-live="polite">
          Ready to refresh playlist metadata.
        </div>
      </section>

      <div class="tracked-detail-stack">
        {% set variant = 'detail' %}
        {% include "_components/tracked_card.html" %}

        <section class="toolbar-panel">
          <div class="toolbar-actions">
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="insights"
              aria-pressed="true"
            >
              Insights
            </button>
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="dedicated"
              aria-pressed="false"
            >
              Dedicated Scan
            </button>
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="latest"
              aria-pressed="false"
            >
              Latest Scan Results
            </button>
            <button
              class="btn btn-secondary scan-tab-button"
              type="button"
              data-scan-tab="history"
              aria-pressed="false"
            >
              Scan History
            </button>
          </div>
        </section>

        <section class="panel insights-panel is-active" id="insights-section">
          <div class="panel-header">
            <h2>Insights</h2>
            <p>Follower trends and summary metrics for this playlist.</p>
          </div>
          <div class="panel-body insights-body" id="insights-root">
            <section class="insights-block insights-graph">
              <div class="insights-block-header">
                <div>
                  <h3>Follower Change Graph</h3>
                  <p class="summary-note">Daily follower snapshots over time.</p>
                </div>
                <div class="insights-range" data-insights-range>
                  <button
                    class="pill pill-secondary is-active"
                    type="button"
                    data-insights-range-button
                    data-range="7d"
                  >
                    7D
                  </button>
                  <button class="pill pill-secondary" type="button" data-insights-range-button data-range="30d">
                    30D
                  </button>
                  <button class="pill pill-secondary" type="button" data-insights-range-button data-range="3m">
                    3M
                  </button>
                  <button class="pill pill-secondary" type="button" data-insights-range-button data-range="6m">
                    6M
                  </button>
                  <button class="pill pill-secondary" type="button" data-insights-range-button data-range="12m">
                    12M
                  </button>
                  <button class="pill pill-secondary" type="button" data-insights-range-button data-range="all">
                    ALL
                  </button>
                </div>
              </div>
              <div class="insights-chart" id="follower-graph-root">
                <section
                  class="graph-container"
                  id="follower-graph-container"
                  data-graph-container
                  data-insights-chart
                ></section>
              </div>
            </section>

            <section class="insights-block insights-daily">
              <div class="insights-block-header">
                <div>
                  <h3>Daily Summary</h3>
                  <p class="summary-note">Changes vs previous available day</p>
                </div>
              </div>
              <div class="insights-daily-card" data-insights-daily-card>
                <p class="insights-daily-dates" data-insights-daily-dates></p>
                <section
                  class="summary-placeholder empty-state"
                  data-insights-daily-empty
                  data-daily-placeholder
                  hidden
                >
                  Not enough history yet — capture at least two days.
                </section>
                <section
                  class="insights-daily-metrics summary-metrics"
                  data-insights-daily-metrics
                  data-daily-metrics
                >
                  <div
                    class="insights-daily-row insights-metric-row"
                    data-insights-metric-row
                    data-insights-summary="daily"
                    data-insights-metric="followers"
                  >
                    <span class="insights-daily-label">FOLLOWERS</span>
                    <span class="insights-daily-value" data-insights-daily-followers></span>
                  </div>
                  <div
                    class="insights-daily-row insights-metric-row"
                    data-insights-metric-row
                    data-insights-summary="daily"
                    data-insights-metric="improved"
                  >
                    <span class="insights-daily-label">IMPROVED POSITIONS</span>
                    <span class="insights-daily-value" data-insights-daily-improved></span>
                  </div>
                  <div
                    class="insights-daily-row insights-metric-row"
                    data-insights-metric-row
                    data-insights-summary="daily"
                    data-insights-metric="declined"
                  >
                    <span class="insights-daily-label">DECLINED POSITIONS</span>
                    <span class="insights-daily-value" data-insights-daily-declined></span>
                  </div>
                  <div
                    class="insights-daily-row insights-metric-row"
                    data-insights-metric-row
                    data-insights-summary="daily"
                    data-insights-metric="unchanged"
                  >
                    <span class="insights-daily-label">UNCHANGED</span>
                    <span class="insights-daily-value" data-insights-daily-unchanged></span>
                  </div>
                </section>
              </div>
              <div class="insights-drilldown-slot" data-insights-drilldown-slot="daily"></div>
            </section>

            <section class="insights-block insights-weekly">
              <div class="insights-block-header">
                <div>
                  <h3>Weekly Summary</h3>
                  <p class="summary-note">Weekly follower change and position shifts.</p>
                </div>
              </div>
              <div class="insights-weekly-card-wrap">
                <div class="insights-daily-card insights-weekly-card" data-insights-weekly-card>
                  <div>
                    <p class="insights-daily-dates" data-insights-weekly-dates></p>
                  </div>
                  <section
                    class="summary-placeholder empty-state"
                    data-insights-weekly-empty
                    data-weekly-placeholder
                    hidden
                  >
                    Not enough history yet — capture at least two days.
                  </section>
                  <section
                    class="insights-weekly-metrics summary-metrics"
                    data-insights-weekly-metrics
                    data-weekly-metrics
                  >
                    <div
                      class="insights-daily-row insights-metric-row"
                      data-insights-metric-row
                      data-insights-summary="weekly"
                      data-insights-metric="followers"
                    >
                      <span class="insights-daily-label">FOLLOWERS</span>
                      <span class="insights-daily-value" data-insights-weekly-followers></span>
                    </div>
                    <div
                      class="insights-daily-row insights-metric-row"
                      data-insights-metric-row
                      data-insights-summary="weekly"
                      data-insights-metric="improved"
                    >
                      <span class="insights-daily-label">IMPROVED POSITIONS</span>
                      <span class="insights-daily-value" data-insights-weekly-improved></span>
                    </div>
                    <div
                      class="insights-daily-row insights-metric-row"
                      data-insights-metric-row
                      data-insights-summary="weekly"
                      data-insights-metric="declined"
                    >
                      <span class="insights-daily-label">DECLINED POSITIONS</span>
                      <span class="insights-daily-value" data-insights-weekly-declined></span>
                    </div>
                    <div
                      class="insights-daily-row insights-metric-row"
                      data-insights-metric-row
                      data-insights-summary="weekly"
                      data-insights-metric="unchanged"
                    >
                      <span class="insights-daily-label">UNCHANGED</span>
                      <span class="insights-daily-value" data-insights-weekly-unchanged></span>
                    </div>
                  </section>
                </div>
              </div>
              <div class="insights-drilldown-slot" data-insights-drilldown-slot="weekly"></div>
            </section>
          </div>
        </section>

        <section class="panel basic-scan-panel is-hidden" id="basic-scan-section">
          <div class="panel-header">
            <h2>Dedicated Scan</h2>
            <p>Run a manual scan using stored targets.</p>
          </div>
          <div class="panel-body">
            <div class="basic-scan" data-basic-scan data-tracked-playlist-id="{{ playlist.id }}">
              <section class="scan-parameters" id="scan-parameters" data-basic-scan-parameters>
                <div class="scan-config-row">
                  <span class="scan-config-label">Countries</span>
                  <div class="pill-list" data-basic-scan-countries>
                    {% if playlist.target_countries %}
                      {% for country in playlist.target_countries %}
                        {% set label = playlist.target_country_labels.get(country|upper, country) %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ label }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target countries</span>
                    {% endif %}
                  </div>
                </div>
                <div class="scan-config-row">
                  <span class="scan-config-label">Keywords</span>
                  <div class="pill-list" data-basic-scan-keywords>
                    {% if playlist.target_keywords %}
                      {% for keyword in playlist.target_keywords %}
                        <span class="chip chip-locked">
                          <span class="chip-label">{{ keyword }}</span>
                        </span>
                      {% endfor %}
                    {% else %}
                      <span class="scan-config-empty">No target keywords</span>
                    {% endif %}
                  </div>
                </div>
                <div class="run-scan-controls" id="run-scan-controls" data-basic-scan-run-controls>
                  <button class="btn btn-primary" type="button" data-basic-scan-run>
                    Run Dedicated Scan
                  </button>
                </div>
              </section>
              <section
                class="run-progress basic-scan-progress"
                id="basic-scan-progress"
                data-basic-scan-progress
                hidden
              >
                <div class="progress-bar">
                  <div class="progress-fill" data-basic-scan-progress-fill></div>
                </div>
                <div class="progress-status" data-basic-scan-progress-status>Starting scan…</div>
                <div class="progress-helper" data-basic-scan-progress-helper>
                  Your scan is still in progress. Estimating remaining time. Refresh this page soon to
                  see your scan results.
                </div>
                <div class="progress-log" data-basic-scan-progress-log></div>
                <div class="progress-actions">
                  <button
                    class="btn btn-secondary"
                    type="button"
                    data-basic-scan-stop
                    hidden
                  >
                    Stop Scan
                  </button>
                </div>
              </section>
            </div>
          </div>
        </section>

        <section class="panel latest-scan-panel is-hidden" id="latest-scan-section">
          <div class="panel-header">
            <h2>Latest Scan Results</h2>
            <p>Most recent completed scan, refreshed on every visit.</p>
          </div>
          <div class="panel-body">
            <div class="latest-scan" data-latest-scan data-tracked-playlist-id="{{ playlist.id }}">
              {% set results_id = 'latest-scan-results' %}
              {% set results_title = 'Latest Scan Results' %}
              {% set data_prefix = 'latest-scan' %}
              {% set csv_controls_id = 'latest-scan-csv-controls' %}
              {% set summary_id = 'latest-scan-summary' %}
              {% set detailed_id = 'latest-scan-detailed' %}
              {% include "_components/scan_results.html" %}
            </div>
          </div>
        </section>

        <section class="panel scan-history-panel is-hidden" id="scan-history-section">
          <div class="panel-header scan-history-header">
            <div>
              <h2>Scan History</h2>
              <p>Recent scan runs for this playlist.</p>
            </div>
            <div class="scan-history-actions">
              <button
                class="pill pill-primary"
                type="button"
                data-scan-history-compare-toggle
                aria-pressed="false"
              >
                Compare Results
              </button>
              <button
                class="pill pill-secondary"
                type="button"
                data-scan-history-compare-cancel
                hidden
              >
                Cancel
              </button>
              <button
                class="pill pill-primary scan-history-compare-run"
                type="button"
                data-scan-history-compare-run
                disabled
                hidden
              >
                Compare
              </button>
              <button
                class="pill pill-dark"
                type="button"
                data-scan-history-compare-close
                hidden
              >
                Close
              </button>
            </div>
          </div>
          <div class="panel-body">
            <div class="scan-history" data-scan-history data-tracked-playlist-id="{{ playlist.id }}">
              <div class="scan-history-list" data-scan-history-list>
                <p class="summary-note" data-scan-history-empty hidden>
                  No scan history yet for this playlist.
                </p>
                <div class="table-scroll" data-scan-history-table hidden>
                  <table class="results-table scan-history-table">
                    <thead>
                      <tr>
                        <th class="scan-history-col-country">Country</th>
                        <th class="scan-history-col-keyword">Keyword</th>
                        <th class="scan-history-col-status">Status</th>
                        <th class="scan-history-col-date">Scan date</th>
                        <th
                          class="scan-history-compare-column"
                          data-scan-history-compare-column
                          hidden
                        ></th>
                      </tr>
                    </thead>
                    <tbody data-scan-history-body></tbody>
                  </table>
                </div>
              </div>
            </div>
            <section class="panel scan-history-compare-panel" data-scan-history-compare hidden>
              <div class="panel-header scan-history-compare-header">
                <div>
                  <h2>Comparison Results</h2>
                  <p>Review the differences between two scans.</p>
                </div>
                <div class="scan-history-compare-header-actions">
                  <button
                    class="btn btn-secondary btn-csv"
                    type="button"
                    data-scan-history-compare-download
                    hidden
                  >
                    Download Comparison CSV
                  </button>
                </div>
              </div>
              <div class="panel-body">
                <p class="summary-note scan-history-compare-message" data-scan-history-compare-message hidden></p>
                <div class="scan-history-compare-summary" data-scan-history-compare-summary></div>
                <div class="scan-history-compare-followers" data-scan-history-compare-followers hidden>
                  <div class="comparison-metrics-table-wrap">
                    <table class="results-table comparison-table comparison-followers-table">
                      <thead>
                        <tr>
                          <th>Metric</th>
                          <th>Scan A</th>
                          <th>Scan B</th>
                          <th>Change</th>
                        </tr>
                      </thead>
                      <tbody data-scan-history-compare-followers-body></tbody>
                    </table>
                  </div>
                </div>
                <div class="table-scroll" data-scan-history-compare-table hidden>
                  <table class="results-table comparison-table">
                    <thead>
                      <tr>
                        <th>Country</th>
                        <th>Keyword</th>
                        <th>Rank A</th>
                        <th>Rank B</th>
                        <th>Position change</th>
                      </tr>
                    </thead>
                    <tbody data-scan-history-compare-body></tbody>
                  </table>
                </div>
              </div>
            </section>
            <section class="panel scan-history-detail-panel" data-scan-history-detail hidden>
              <div class="panel-header">
                <h2>Scan Details</h2>
                <p>Review a completed scan run.</p>
              </div>
              <div class="panel-body">
                <div class="scan-history-detail-actions">
                  <button class="btn btn-secondary" type="button" data-scan-history-back>
                    Back to Scan History
                  </button>
                </div>
                <p class="summary-note scan-history-detail-message" data-scan-history-detail-message hidden></p>
                <div class="scan-history-detail-results" data-scan-history-detail-results>
                  {% set results_id = 'scan-history-detail-results' %}
                  {% set results_title = 'Scan Details' %}
                  {% set data_prefix = 'history-detail' %}
                  {% set csv_controls_id = 'scan-history-detail-csv-controls' %}
                  {% set summary_id = 'scan-history-detail-summary' %}
                  {% set detailed_id = 'scan-history-detail-detailed' %}
                  {% include "_components/scan_results.html" %}
                </div>
              </div>
            </section>
          </div>
        </section>
      </div>
    </main>

    <script>
      const statusArea = document.getElementById('playlist-status');
      const refreshButton = document.querySelector('[data-refresh-stats]');
      const playlistDetailRoot = document.querySelector('[data-tracked-card][data-playlist-id]');
      const playlistId = playlistDetailRoot?.dataset.playlistId || null;
      const ownerValue = playlistDetailRoot?.querySelector('[data-playlist-owner]') || null;
      const followersValue = playlistDetailRoot?.querySelector('[data-playlist-followers]') || null;
      const tracksValue = playlistDetailRoot?.querySelector('[data-playlist-tracks]') || null;
      const scannedValue = playlistDetailRoot?.querySelector('[data-playlist-scanned]') || null;
      const updatedValue = playlistDetailRoot?.querySelector('[data-playlist-updated]') || null;
      const toolbarButtons = document.querySelectorAll('[data-panel-target]');
      const panels = document.querySelectorAll('.panel[data-panel]');
      const toolbar = document.querySelector('.toolbar-panel');
      let lastAnchor = toolbar;
      const insightsSection = document.getElementById('insights-section');
      const basicScanSection = document.getElementById('basic-scan-section');
      const latestScanSection = document.getElementById('latest-scan-section');
      const scanHistorySection = document.getElementById('scan-history-section');
      const scanTabButtons = document.querySelectorAll('[data-scan-tab]');
      let basicScanStageController = null;
      let activeSection = null;
      let loadInsights = null;
      let loadLatestScan = null;
      let loadScanHistory = null;
      let resetHistoryDetail = null;
      let resetHistoryCompare = null;
      let lastTabScrollY = null;
      let activeScanStatus = null;

      const togglePanel = (targetId) => {
        let activePanel = null;
        panels.forEach((panel) => {
          if (panel.id === targetId) {
            activePanel = panel;
          }
        });

        if (!activePanel) {
          return;
        }

        const isActive = activePanel.classList.contains('is-active');
        panels.forEach((panel) => panel.classList.remove('is-active'));

        if (!isActive) {
          lastAnchor = toolbar || document.body;
          activePanel.classList.add('is-active');
          activePanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          return;
        }

        if (lastAnchor) {
          lastAnchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      toolbarButtons.forEach((button) => {
        button.addEventListener('click', () => {
          togglePanel(button.dataset.panelTarget);
        });
      });

      if (panels.length) {
        panels[0].classList.add('is-active');
      }

      const showSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = false;
        section.style.removeProperty('display');
      };

      const hideSection = (section) => {
        if (!section) {
          return;
        }
        section.hidden = true;
        section.style.display = 'none';
      };

      const scrollSectionToCenter = (section) => {
        if (!section) {
          return;
        }
        const rect = section.getBoundingClientRect();
        const sectionTop = window.scrollY + rect.top;
        const target =
          sectionTop - window.innerHeight / 2 + rect.height / 2;
        window.scrollTo({ top: Math.max(target, 0), behavior: 'smooth' });
      };

      const setActiveSection = (nextTab, options = {}) => {
        if (!nextTab || nextTab === activeSection) {
          return;
        }
        if (
          nextTab !== 'dedicated' &&
          ['queued', 'running'].includes(activeScanStatus) &&
          !options.allowRunningSwitch
        ) {
          return;
        }
        if (nextTab !== 'history' && typeof resetHistoryDetail === 'function') {
          resetHistoryDetail({ skipScroll: true });
        }
        if (nextTab !== 'history' && typeof resetHistoryCompare === 'function') {
          resetHistoryCompare({ skipScroll: true });
        }
        lastTabScrollY = window.scrollY;
        activeSection = nextTab;

        const setSectionActive = (section, isActive) => {
          if (!section) {
            return;
          }
          section.classList.toggle('is-active', isActive);
          section.classList.toggle('is-hidden', !isActive);
        };

        setSectionActive(insightsSection, nextTab === 'insights');
        setSectionActive(basicScanSection, nextTab === 'dedicated');
        setSectionActive(latestScanSection, nextTab === 'latest');
        setSectionActive(scanHistorySection, nextTab === 'history');

        if (nextTab === 'dedicated' && basicScanStageController) {
          basicScanStageController.setStage(basicScanStageController.getStage());
        }

        scanTabButtons.forEach((button) => {
          const isActive = button.dataset.scanTab === activeSection;
          button.setAttribute('aria-pressed', String(isActive));
          button.classList.toggle('is-active', isActive);
        });

        if (nextTab === 'latest' && !options.skipFetch && typeof loadLatestScan === 'function') {
          loadLatestScan();
        }
        if (nextTab === 'history' && !options.skipFetch && typeof loadScanHistory === 'function') {
          loadScanHistory();
        }
        if (nextTab === 'insights' && !options.skipFetch && typeof loadInsights === 'function') {
          loadInsights();
        }

        if (!options.skipScroll && lastTabScrollY !== null) {
          window.scrollTo({ top: lastTabScrollY, behavior: 'smooth' });
        }
      };

      scanTabButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          const nextTab = button.dataset.scanTab;
          setActiveSection(nextTab);
        });
      });

      const setStatus = (message, variant) => {
        if (!statusArea) {
          return;
        }
        statusArea.textContent = message;
        statusArea.classList.remove('status-success', 'status-error', 'status-loading');
        if (variant) {
          statusArea.classList.add(variant);
        }
      };

      const readErrorPayload = async (response) => {
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          try {
            return await response.json();
          } catch (error) {
            return null;
          }
        }
        try {
          const text = await response.text();
          return text || null;
        } catch (error) {
          return null;
        }
      };

      const parseJsonSafely = async (response) => {
        try {
          return await response.json();
        } catch (error) {
          return null;
        }
      };

      const normalizeErrorMessage = (payload, fallback) => {
        if (!payload) {
          return fallback;
        }
        if (typeof payload === 'string') {
          return payload;
        }
        const detail = payload.detail ?? payload.message ?? payload.error ?? payload;
        if (typeof detail === 'string') {
          return detail;
        }
        try {
          return JSON.stringify(detail);
        } catch (error) {
          return fallback;
        }
      };

      const formatFollowersValue = (value) => {
        if (value === undefined || value === null || value === '') {
          return '—';
        }
        if (typeof value === 'object') {
          if ('total' in value) {
            return formatFollowersValue(value.total);
          }
          return '—';
        }
        const numeric = Number(value);
        if (Number.isFinite(numeric)) {
          return numeric.toLocaleString();
        }
        return value;
      };

      const formatRelativeTime = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '—';
        }
        const deltaSeconds = Math.max(0, Math.floor((Date.now() - date.getTime()) / 1000));
        if (deltaSeconds < 60) {
          return 'just now';
        }
        const minutes = Math.floor(deltaSeconds / 60);
        if (minutes < 60) {
          return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} ago`;
        }
        const hours = Math.floor(minutes / 60);
        if (hours < 24) {
          return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`;
        }
        const days = Math.floor(hours / 24);
        return `${days} ${days === 1 ? 'day' : 'days'} ago`;
      };

      const captureDomSnapshot = () => ({
        owner: ownerValue?.textContent?.trim() || '',
        followers: followersValue?.textContent?.trim() || '',
        tracks: tracksValue?.textContent?.trim() || '',
        scanned: scannedValue?.textContent?.trim() || '',
        updated: updatedValue?.textContent?.trim() || '',
      });

      const buildDataSnapshot = (data) => ({
        owner: data?.owner_name || '—',
        followers: formatFollowersValue(data?.followers_total),
        tracks: formatFollowersValue(data?.tracks_count),
        scanned: formatRelativeTime(data?.stats_updated_at),
        updated: formatRelativeTime(data?.playlist_last_updated_at),
      });

      const snapshotsDiffer = (next, baseline) =>
        Object.keys(baseline || {}).some((key) => (next?.[key] || '') !== (baseline?.[key] || ''));

      const applyPlaylistData = (data) => {
        if (!data) {
          return;
        }
        if (ownerValue) {
          ownerValue.textContent = data.owner_name || '—';
        }
        if (followersValue) {
          followersValue.textContent = formatFollowersValue(data.followers_total);
        }
        if (tracksValue) {
          tracksValue.textContent = formatFollowersValue(data.tracks_count);
        }
        if (scannedValue) {
          scannedValue.textContent = formatRelativeTime(data.stats_updated_at);
        }
        if (updatedValue) {
          updatedValue.textContent = formatRelativeTime(data.playlist_last_updated_at);
        }
      };

      const fetchPlaylistDetail = async () => {
        if (!playlistId) {
          return null;
        }
        const response = await fetch('/api/playlists');
        if (!response.ok) {
          return null;
        }
        const payload = await parseJsonSafely(response);
        if (!Array.isArray(payload)) {
          return null;
        }
        return payload.find((item) => String(item.id) === String(playlistId)) || null;
      };

      const pollForPlaylistUpdate = async (baselineSnapshot, baselineRefreshAt) => {
        const POLL_INTERVAL_MS = 2000;
        const MAX_ATTEMPTS = 30;
        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
          try {
            const data = await fetchPlaylistDetail();
            if (data) {
              const currentSnapshot = buildDataSnapshot(data);
              const refreshAt = data.last_meta_refresh_at || null;
              if (
                snapshotsDiffer(currentSnapshot, baselineSnapshot) ||
                (baselineRefreshAt && refreshAt && refreshAt !== baselineRefreshAt)
              ) {
                applyPlaylistData(data);
                return { updated: true, data };
              }
            }
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[ui] refresh stats polling failed', error);
            }
          }
          await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL_MS));
        }
        return { updated: false, data: null };
      };

      refreshButton?.addEventListener('click', async () => {
        if (!refreshButton || !playlistDetailRoot || !playlistId) {
          return;
        }
        refreshButton.disabled = true;
        setStatus('Fetching data from Spotify… please wait', 'status-loading');
        let didUpdate = false;
        let baselineSnapshot = captureDomSnapshot();
        let baselineRefreshAt = null;

        try {
          const preRefreshData = await fetchPlaylistDetail();
          if (preRefreshData) {
            baselineSnapshot = buildDataSnapshot(preRefreshData);
            baselineRefreshAt = preRefreshData.last_meta_refresh_at || null;
          }
          const response = await fetch(`/api/playlists/{{ playlist.id }}/refresh-stats`, {
            method: 'POST',
          });
          if (!response.ok) {
            const errorPayload = await readErrorPayload(response);
            const message = normalizeErrorMessage(
              errorPayload,
              'Unable to refresh playlist metadata.'
            );
            setStatus(message, 'status-error');
            return;
          }

          let data = null;
          data = await parseJsonSafely(response);
          const refreshedAt =
            data && typeof data === 'object' && data.refreshed_at ? new Date(data.refreshed_at) : null;
          const queuedAt =
            data && typeof data === 'object' && data.queued_at ? new Date(data.queued_at) : null;
          if (refreshedAt) {
            const timeLabel = refreshedAt.toLocaleString();
            setStatus(`✅ Playlist metadata refreshed at ${timeLabel}`, 'status-success');
          } else {
            const queuedLabel = queuedAt ? queuedAt.toLocaleString() : 'just now';
            const statusLabel =
              data && typeof data === 'object' && data.status === 'already_running'
                ? 'Already running'
                : 'Queued';
            setStatus(`⏳ ${statusLabel}: refresh scheduled at ${queuedLabel}.`, 'status-success');
          }

          const pollResult = await pollForPlaylistUpdate(baselineSnapshot, baselineRefreshAt);
          if (pollResult.updated) {
            didUpdate = true;
            setStatus('✅ Playlist stats updated.', 'status-success');
            if (typeof loadInsights === 'function') {
              loadInsights();
            }
          } else {
            setStatus(
              'Refresh completed, but UI update timed out. Please reload.',
              'status-error'
            );
          }
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[ui] refresh stats failed', error);
          }
          const message = normalizeErrorMessage(
            error,
            'Network error while refreshing playlist.'
          );
          setStatus(message, 'status-error');
        } finally {
          refreshButton.disabled = false;
          if (!didUpdate && statusArea?.classList.contains('status-loading')) {
            setStatus('Unable to refresh playlist metadata.', 'status-error');
          }
        }
      });

      const availableMarkets = {{ available_markets | tojson }};
      const marketLabelMap = new Map(
        availableMarkets.map((market) => [market.code.toUpperCase(), market.label])
      );

      const resolveMarketLabel = (code) => marketLabelMap.get((code || '').toUpperCase()) || code;

      const formatTimestamp = (value) => {
        if (!value) {
          return '—';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return new Intl.DateTimeFormat('sv-SE', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
        }).format(date);
      };

      const formatSummaryDateParts = (value) => {
        if (!value) {
          return { dateLabel: '—', timeLabel: '—' };
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return { dateLabel: value, timeLabel: value };
        }
        const dateLabel = date.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        });
        const timeLabel = date.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
        });
        return { dateLabel, timeLabel };
      };

      const formatFileTimestamp = (value) => {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        const pad = (part) => String(part).padStart(2, '0');
        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        return `${day}-${month}-${year}_${hours}-${minutes}`;
      };

      const flagEmoji = (code) => {
        const upper = (code || '').toUpperCase();
        if (upper.length !== 2) {
          return '';
        }
        return upper.replace(/./g, (char) => String.fromCodePoint(127397 + char.charCodeAt()));
      };

      const insightsElements = {
        chart: document.querySelector('[data-insights-chart]'),
        dailyCard: document.querySelector('[data-insights-daily-card]'),
        dailyDates: document.querySelector('[data-insights-daily-dates]'),
        dailyFollowers: document.querySelector('[data-insights-daily-followers]'),
        dailyImproved: document.querySelector('[data-insights-daily-improved]'),
        dailyDeclined: document.querySelector('[data-insights-daily-declined]'),
        dailyUnchanged: document.querySelector('[data-insights-daily-unchanged]'),
        dailyEmpty: document.querySelector('[data-daily-placeholder]'),
        dailyMetrics: document.querySelector('[data-daily-metrics]'),
        weeklyCard: document.querySelector('[data-insights-weekly-card]'),
        weeklyDates: document.querySelector('[data-insights-weekly-dates]'),
        weeklyFollowers: document.querySelector('[data-insights-weekly-followers]'),
        weeklyImproved: document.querySelector('[data-insights-weekly-improved]'),
        weeklyDeclined: document.querySelector('[data-insights-weekly-declined]'),
        weeklyUnchanged: document.querySelector('[data-insights-weekly-unchanged]'),
        weeklyEmpty: document.querySelector('[data-weekly-placeholder]'),
        weeklyMetrics: document.querySelector('[data-weekly-metrics]'),
      };
      const drilldownSlots = {
        daily: document.querySelector('[data-insights-drilldown-slot="daily"]'),
        weekly: document.querySelector('[data-insights-drilldown-slot="weekly"]'),
      };
      const insightsMetricRows = document.querySelectorAll('[data-insights-metric-row]');
      const insightsRangeButtons = document.querySelectorAll('[data-insights-range-button]');
      let insightsPayload = null;
      let activeInsightsRange = '7d';
      let insightsLoading = false;
      let insightsReloadRequested = false;
      let activeDrilldown = null;

      const parseSnapshotDate = (value) => {
        if (!value) {
          return null;
        }
        const date = new Date(`${value}T00:00:00Z`);
        if (Number.isNaN(date.getTime())) {
          return null;
        }
        return date;
      };

      const formatInsightsDate = (date) =>
        date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });

      const formatInsightsDateShort = (date) =>
        date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });

      const formatBucketLabel = (date) =>
        date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });

      const startOfMonthUTC = (year, month) => new Date(Date.UTC(year, month, 1));

      const buildRangeAnchors = (firstDate, lastDate, rangeKey) => {
        if (!lastDate) {
          return [];
        }
        if (rangeKey === '7d') {
          const start = new Date(
            Date.UTC(
              lastDate.getUTCFullYear(),
              lastDate.getUTCMonth(),
              lastDate.getUTCDate() - 6
            )
          );
          return Array.from({ length: 7 }, (_, index) =>
            new Date(
              Date.UTC(
                start.getUTCFullYear(),
                start.getUTCMonth(),
                start.getUTCDate() + index
              )
            )
          );
        }
        if (rangeKey === '30d') {
          const start = new Date(
            Date.UTC(
              lastDate.getUTCFullYear(),
              lastDate.getUTCMonth(),
              lastDate.getUTCDate() - 21
            )
          );
          return Array.from({ length: 4 }, (_, index) =>
            new Date(
              Date.UTC(
                start.getUTCFullYear(),
                start.getUTCMonth(),
                start.getUTCDate() + index * 7
              )
            )
          );
        }
        if (rangeKey === '3m') {
          const latestMonthStart = startOfMonthUTC(
            lastDate.getUTCFullYear(),
            lastDate.getUTCMonth()
          );
          return Array.from({ length: 3 }, (_, index) =>
            startOfMonthUTC(
              latestMonthStart.getUTCFullYear(),
              latestMonthStart.getUTCMonth() - (2 - index)
            )
          );
        }
        if (rangeKey === '6m') {
          const latestMonthStart = startOfMonthUTC(
            lastDate.getUTCFullYear(),
            lastDate.getUTCMonth()
          );
          return Array.from({ length: 6 }, (_, index) =>
            startOfMonthUTC(
              latestMonthStart.getUTCFullYear(),
              latestMonthStart.getUTCMonth() - (5 - index)
            )
          );
        }
        if (rangeKey === '12m') {
          const quarterStartMonth = Math.floor(lastDate.getUTCMonth() / 3) * 3;
          const latestQuarterStart = startOfMonthUTC(
            lastDate.getUTCFullYear(),
            quarterStartMonth
          );
          return Array.from({ length: 4 }, (_, index) =>
            startOfMonthUTC(
              latestQuarterStart.getUTCFullYear(),
              latestQuarterStart.getUTCMonth() - (3 * (3 - index))
            )
          );
        }
        const halfYearStartMonth = lastDate.getUTCMonth() < 6 ? 0 : 6;
        const latestHalfYearStart = startOfMonthUTC(
          lastDate.getUTCFullYear(),
          halfYearStartMonth
        );
        return Array.from({ length: 6 }, (_, index) =>
          startOfMonthUTC(
            latestHalfYearStart.getUTCFullYear(),
            latestHalfYearStart.getUTCMonth() - (6 * (5 - index))
          )
        );
      };

      const bucketSeries = (series, anchors) => {
        if (!anchors.length) {
          return [];
        }
        let pointer = 0;
        return anchors.map((anchor, index) => {
          const nextAnchor = anchors[index + 1] || null;
          while (pointer < series.length && series[pointer].dateObj < anchor) {
            pointer += 1;
          }
          let bucketEntry = null;
          let scanIndex = pointer;
          while (scanIndex < series.length) {
            const entry = series[scanIndex];
            const withinWindow = !nextAnchor || entry.dateObj < nextAnchor;
            if (entry.dateObj < anchor) {
              scanIndex += 1;
              continue;
            }
            if (!withinWindow) {
              break;
            }
            bucketEntry = entry;
            break;
          }
          if (bucketEntry) {
            pointer = scanIndex;
          }
          return { anchor, entry: bucketEntry };
        });
      };

      const buildYAxisTicks = (minValue, maxValue, tickCount) => {
        if (!Number.isFinite(minValue) || !Number.isFinite(maxValue) || tickCount <= 0) {
          return [];
        }
        const range = Math.max(maxValue - minValue, 1);
        const step = range / Math.max(tickCount - 1, 1);
        return Array.from({ length: tickCount }, (_, index) => maxValue - step * index);
      };

      const getRangeTickCount = () => {
        const tickCounts = {
          '7d': 7,
          '30d': 4,
          '3m': 3,
          '6m': 6,
          '12m': 4,
          all: 6,
        };
        return tickCounts[activeInsightsRange] || 7;
      };

      const normalizeTimeseries = (payload) => {
        const raw = Array.isArray(payload?.follower_timeseries)
          ? payload.follower_timeseries
          : [];
        return raw
          .map((entry) => {
            const dateObj = parseSnapshotDate(entry?.date);
            if (!dateObj) {
              return null;
            }
            const followers = Number(entry.followers);
            if (!Number.isFinite(followers)) {
              return null;
            }
            return {
              dateObj,
              dateKey: entry.date,
              followers,
            };
          })
          .filter(Boolean)
          .sort((a, b) => a.dateObj - b.dateObj);
      };

      const updateInsightsRangeButtons = () => {
        insightsRangeButtons.forEach((button) => {
          const isActive = button.dataset.range === activeInsightsRange;
          button.classList.toggle('is-active', isActive);
        });
      };

      const filterInsightsRange = (series, rangeKey) => {
        if (!series.length) {
          return [];
        }
        const anchors = buildRangeAnchors(
          series[0].dateObj,
          series[series.length - 1].dateObj,
          rangeKey
        );
        if (!anchors.length) {
          return [];
        }
        const rangeStart = anchors[0];
        return series.filter((entry) => entry.dateObj >= rangeStart);
      };

      const describeDelta = (delta) => {
        if (delta > 0) {
          return { text: `↑ ${delta}`, className: 'delta-up' };
        }
        if (delta < 0) {
          return { text: `↓ ${Math.abs(delta)}`, className: 'delta-down' };
        }
        return { text: '—', className: 'delta-neutral' };
      };

      const formatChangeArrow = (value, mode) => {
        const num = Number(value || 0);
        const abs = Math.abs(num);
        const formatted = abs.toLocaleString('en-US');

        if (mode === 'improved') {
          return { text: `↑${formatted}`, className: 'change-up' };
        }

        if (mode === 'declined') {
          return { text: `↓${formatted}`, className: 'change-down' };
        }

        if (num > 0) {
          return { text: `↑${formatted}`, className: 'change-up' };
        }

        if (num < 0) {
          return { text: `↓${formatted}`, className: 'change-down' };
        }

        return { text: '0', className: 'change-neutral' };
      };

      const parseChangeValue = (value) => {
        if (value === null || typeof value === 'undefined') {
          return null;
        }
        const match = String(value)
          .replace(/\s+/g, '')
          .match(/[-+]?\d+(?:,\d+)*/);
        if (!match) {
          return null;
        }
        const numeric = Number(match[0].replace(/,/g, ''));
        return Number.isFinite(numeric) ? numeric : null;
      };

      const applyChangeArrowFormatting = (cell, mode) => {
        if (!cell || !mode) {
          return;
        }
        const rawValue = parseChangeValue(cell.textContent);
        if (rawValue === null) {
          return;
        }
        const { text, className } = formatChangeArrow(rawValue, mode);
        cell.innerHTML = `<span class="${className}">${text}</span>`;
      };

      const applyDrilldownChangeFormatting = (slot, metric) => {
        if (!slot) {
          return;
        }
        const modeMap = {
          improved: 'improved',
          declined: 'declined',
          followers: 'followers',
        };
        const mode = modeMap[(metric || '').toLowerCase()];
        if (!mode) {
          return;
        }
        const changeCells = slot.querySelectorAll('table tbody tr td:last-child');
        changeCells.forEach((cell) => applyChangeArrowFormatting(cell, mode));
      };

      const hasSummaryData = (compare) => {
        if (!compare) {
          return false;
        }
        const followerDelta = compare?.followers_change;
        const hasFollowerDelta = followerDelta !== null && followerDelta !== undefined;
        const improved = Number(compare?.improved_positions) || 0;
        const declined = Number(compare?.declined_positions) || 0;
        const unchanged = Number(compare?.unchanged_positions) || 0;
        return hasFollowerDelta || improved + declined + unchanged > 0;
      };

      const buildPointsForRange = (rangeKey, series) => filterInsightsRange(series, rangeKey);

      const renderFollowerGraph = (points) => {
        if (!insightsElements.chart) {
          return;
        }
        insightsElements.chart.innerHTML = '';
        const hasChartPoints = points.length >= 1;
        if (!hasChartPoints) {
          return;
        }
        const firstEntry = points[0];
        const lastEntry = points[points.length - 1];
        const anchors = buildRangeAnchors(
          firstEntry?.dateObj || null,
          lastEntry?.dateObj || null,
          activeInsightsRange
        );
        const buckets = bucketSeries(points, anchors);
        const bucketValues = buckets
          .map((bucket) => (bucket.entry ? bucket.entry.followers : null))
          .filter((value) => Number.isFinite(value));

        const width = insightsElements.chart.clientWidth || 600;
        const height = 240;
        const padding = { top: 16, right: 16, bottom: 32, left: 48 };
        const plotWidth = Math.max(width - padding.left - padding.right, 1);
        const plotHeight = Math.max(height - padding.top - padding.bottom, 1);

        const minValue = Math.min(...bucketValues);
        const maxValue = Math.max(...bucketValues);
        const range = Math.max(maxValue - minValue, 1);
        const tickCount = getRangeTickCount();
        const yTicks = buildYAxisTicks(minValue, maxValue, tickCount);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('role', 'img');
        svg.setAttribute('aria-label', 'Follower change line chart');

        const axis = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        axis.setAttribute(
          'd',
          `M ${padding.left} ${padding.top} V ${padding.top + plotHeight} H ${
            padding.left + plotWidth
          }`
        );
        axis.setAttribute('fill', 'none');
        axis.setAttribute('stroke', 'rgba(0,0,0,0.1)');
        axis.setAttribute('stroke-width', '1');
        svg.append(axis);

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const xForIndex = (index) =>
          padding.left +
          (anchors.length === 1 ? plotWidth / 2 : (plotWidth * index) / (anchors.length - 1));
        const pathCommands = [];
        let pathStarted = false;
        buckets.forEach((bucket, index) => {
          if (!bucket.entry) {
            pathStarted = false;
            return;
          }
          const x = xForIndex(index);
          const y =
            padding.top + ((maxValue - bucket.entry.followers) / range) * plotHeight;
          if (!pathStarted) {
            pathCommands.push(`M ${x} ${y}`);
            pathStarted = true;
          } else {
            pathCommands.push(`L ${x} ${y}`);
          }
        });
        path.setAttribute('d', pathCommands.join(' '));
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#111111');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        svg.append(path);

        yTicks.forEach((tick) => {
          const y = padding.top + ((maxValue - tick) / range) * plotHeight;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', String(padding.left - 8));
          text.setAttribute('y', String(y));
          text.setAttribute('text-anchor', 'end');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('fill', '#6b6b6b');
          text.setAttribute('font-size', '11');
          text.textContent = Math.round(tick).toLocaleString();
          svg.append(text);
        });

        anchors.forEach((anchorDate, index) => {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', String(xForIndex(index)));
          text.setAttribute('y', String(padding.top + plotHeight + 20));
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('fill', '#6b6b6b');
          text.setAttribute('font-size', '11');
          text.textContent = formatBucketLabel(anchorDate);
          svg.append(text);
        });

        insightsElements.chart.append(svg);
      };

      const setDailyValue = (element, value, className) => {
        if (!element) {
          return;
        }
        element.textContent = value;
        element.classList.remove('delta-up', 'delta-down', 'delta-neutral');
        if (className) {
          element.classList.add(className);
        }
      };

      const renderDailySummary = (payload) => {
        const compare = payload?.daily_compare ?? null;
        if (!insightsElements.dailyCard) {
          return;
        }
        const dailyHasData = hasSummaryData(compare);
        if (!dailyHasData) {
          if (insightsElements.dailyEmpty) {
            insightsElements.dailyEmpty.hidden = false;
          }
          if (insightsElements.dailyDates) {
            insightsElements.dailyDates.hidden = true;
          }
          if (insightsElements.dailyMetrics) {
            insightsElements.dailyMetrics.hidden = true;
          }
          return;
        }
        if (insightsElements.dailyEmpty) {
          insightsElements.dailyEmpty.hidden = true;
        }
        if (insightsElements.dailyDates) {
          insightsElements.dailyDates.hidden = false;
        }
        if (insightsElements.dailyMetrics) {
          insightsElements.dailyMetrics.hidden = false;
        }

        const newerDate = parseSnapshotDate(compare?.date_newer);
        const olderDate = parseSnapshotDate(compare?.date_older);
        if (insightsElements.dailyDates) {
          insightsElements.dailyDates.textContent =
            newerDate && olderDate
              ? `${formatInsightsDate(newerDate)} vs ${formatInsightsDate(olderDate)}`
              : '—';
        }

        const followerChange = Number(compare?.followers_change);
        if (Number.isFinite(followerChange)) {
          const deltaInfo = describeDelta(followerChange);
          setDailyValue(insightsElements.dailyFollowers, deltaInfo.text, deltaInfo.className);
        } else {
          setDailyValue(insightsElements.dailyFollowers, '—', 'delta-neutral');
        }

        const improvedCount = Number(compare?.improved_positions);
        if (Number.isFinite(improvedCount) && improvedCount > 0) {
          setDailyValue(
            insightsElements.dailyImproved,
            `↑${improvedCount}`,
            'delta-up'
          );
        } else {
          setDailyValue(insightsElements.dailyImproved, '—', 'delta-neutral');
        }

        const declinedCount = Number(compare?.declined_positions);
        if (Number.isFinite(declinedCount) && declinedCount > 0) {
          setDailyValue(
            insightsElements.dailyDeclined,
            `↓${declinedCount}`,
            'delta-down'
          );
        } else {
          setDailyValue(insightsElements.dailyDeclined, '—', 'delta-neutral');
        }

        const unchangedCount = Number(compare?.unchanged_positions);
        if (Number.isFinite(unchangedCount)) {
          setDailyValue(
            insightsElements.dailyUnchanged,
            unchangedCount.toLocaleString(),
            'delta-neutral'
          );
        } else {
          setDailyValue(insightsElements.dailyUnchanged, '—', 'delta-neutral');
        }
      };

      const renderWeeklySummary = (payload) => {
        const compare = payload?.weekly_compare ?? null;
        if (!insightsElements.weeklyCard) {
          return;
        }
        const weeklyHasData = hasSummaryData(compare);
        if (!weeklyHasData) {
          if (insightsElements.weeklyEmpty) {
            insightsElements.weeklyEmpty.hidden = false;
          }
          if (insightsElements.weeklyDates) {
            insightsElements.weeklyDates.hidden = true;
          }
          if (insightsElements.weeklyMetrics) {
            insightsElements.weeklyMetrics.hidden = true;
          }
          return;
        }
        if (insightsElements.weeklyEmpty) {
          insightsElements.weeklyEmpty.hidden = true;
        }
        if (insightsElements.weeklyDates) {
          insightsElements.weeklyDates.hidden = false;
        }
        if (insightsElements.weeklyMetrics) {
          insightsElements.weeklyMetrics.hidden = false;
        }

        const newerDate = parseSnapshotDate(compare?.date_newer);
        const olderDate = parseSnapshotDate(compare?.date_older);
        if (insightsElements.weeklyDates) {
          insightsElements.weeklyDates.textContent =
            newerDate && olderDate
              ? `${formatInsightsDate(newerDate)} vs ${formatInsightsDate(olderDate)}`
              : '—';
        }

        const followerChange = Number(compare?.followers_change);
        if (Number.isFinite(followerChange)) {
          const deltaInfo = describeDelta(followerChange);
          setDailyValue(insightsElements.weeklyFollowers, deltaInfo.text, deltaInfo.className);
        } else {
          setDailyValue(insightsElements.weeklyFollowers, '—', 'delta-neutral');
        }

        const improvedCount = Number(compare?.improved_positions);
        if (Number.isFinite(improvedCount) && improvedCount > 0) {
          setDailyValue(
            insightsElements.weeklyImproved,
            `↑${improvedCount}`,
            'delta-up'
          );
        } else {
          setDailyValue(insightsElements.weeklyImproved, '—', 'delta-neutral');
        }

        const declinedCount = Number(compare?.declined_positions);
        if (Number.isFinite(declinedCount) && declinedCount > 0) {
          setDailyValue(
            insightsElements.weeklyDeclined,
            `↓${declinedCount}`,
            'delta-down'
          );
        } else {
          setDailyValue(insightsElements.weeklyDeclined, '—', 'delta-neutral');
        }

        const unchangedCount = Number(compare?.unchanged_positions);
        if (Number.isFinite(unchangedCount)) {
          setDailyValue(
            insightsElements.weeklyUnchanged,
            unchangedCount.toLocaleString(),
            'delta-neutral'
          );
        } else {
          setDailyValue(insightsElements.weeklyUnchanged, '—', 'delta-neutral');
        }
      };

      const clearActiveDrilldown = ({ restoreScroll = true } = {}) => {
        if (!activeDrilldown) {
          return;
        }
        const { slot, row, restoreScrollY } = activeDrilldown;
        if (slot) {
          slot.innerHTML = '';
        }
        if (row) {
          row.classList.remove('is-active');
        }
        if (restoreScroll && Number.isFinite(restoreScrollY)) {
          window.scrollTo({ top: restoreScrollY, behavior: 'smooth' });
        }
        activeDrilldown = null;
      };

      const renderDrilldownError = (slot, message) => {
        if (!slot) {
          return;
        }
        slot.innerHTML = `
          <section class="insights-drilldown" data-insights-drilldown>
            <div class="insights-drilldown-header">
              <h4>Drilldown</h4>
              <button
                class="btn btn-secondary insights-drilldown-close"
                type="button"
                data-insights-drilldown-close
              >
                Close
              </button>
            </div>
            <p class="summary-note">${message}</p>
          </section>
        `;
      };

      const openInsightsDrilldown = async (row) => {
        const summary = row?.dataset?.insightsSummary;
        const metric = row?.dataset?.insightsMetric;
        const slot = drilldownSlots[summary];
        if (!summary || !metric || !slot || !playlistId) {
          return;
        }

        if (activeDrilldown?.summary === summary && activeDrilldown?.metric === metric) {
          clearActiveDrilldown({ restoreScroll: true });
          return;
        }

        clearActiveDrilldown({ restoreScroll: false });

        const restoreScrollY = window.scrollY;
        activeDrilldown = { summary, metric, slot, row, restoreScrollY };
        row.classList.add('is-active');
        slot.innerHTML = `
          <section class="insights-drilldown insights-drilldown-loading" data-insights-drilldown>
            <p class="summary-note">Loading details…</p>
          </section>
        `;

        try {
          const response = await fetch(
            `/playlists/${playlistId}/insights/${summary}/drilldown?metric=${encodeURIComponent(
              metric
            )}`
          );
          if (!response.ok) {
            throw new Error('Unable to load drilldown.');
          }
          const html = await response.text();
          slot.innerHTML = html;
          applyDrilldownChangeFormatting(slot, metric);
          const drilldownSection = slot.querySelector('[data-insights-drilldown]');
          drilldownSection?.scrollIntoView({ behavior: 'smooth', block: 'center' });
          const closeButton = slot.querySelector('[data-insights-drilldown-close]');
          closeButton?.addEventListener('click', (event) => {
            event.preventDefault();
            clearActiveDrilldown({ restoreScroll: true });
          });
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[insights] drilldown failed', error);
          }
          renderDrilldownError(slot, 'Unable to load drilldown details.');
          const closeButton = slot.querySelector('[data-insights-drilldown-close]');
          closeButton?.addEventListener('click', (event) => {
            event.preventDefault();
            clearActiveDrilldown({ restoreScroll: true });
          });
        }
      };

      insightsMetricRows.forEach((row) => {
        row.addEventListener('click', (event) => {
          event.preventDefault();
          openInsightsDrilldown(row);
        });
      });

      const renderInsights = (payload) => {
        const series = normalizeTimeseries(payload);
        const points = buildPointsForRange(activeInsightsRange, series);
        renderFollowerGraph(points);
        renderDailySummary(payload);
        renderWeeklySummary(payload);
      };

      loadInsights = async () => {
        if (!playlistId) {
          return;
        }
        if (insightsLoading) {
          insightsReloadRequested = true;
          return;
        }
        insightsLoading = true;
        try {
          const response = await fetch(`/api/tracked-playlists/${playlistId}/insights`);
          if (!response.ok) {
            const errorPayload = await readErrorPayload(response);
            throw new Error(
              normalizeErrorMessage(errorPayload, 'Unable to load insights data.')
            );
          }
          insightsPayload = await parseJsonSafely(response);
          renderInsights(insightsPayload);
        } catch (error) {
          if (typeof console !== 'undefined' && console.error) {
            console.error('[insights] failed to load', error);
          }
        } finally {
          insightsLoading = false;
          if (insightsReloadRequested) {
            insightsReloadRequested = false;
            await loadInsights();
          }
        }
      };

      insightsRangeButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          activeInsightsRange = button.dataset.range || '7d';
          updateInsightsRangeButtons();
          if (insightsPayload) {
            renderInsights(insightsPayload);
          }
        });
      });

      updateInsightsRangeButtons();

      window.addEventListener('resize', () => {
        if (activeSection === 'insights' && insightsPayload) {
          renderInsights(insightsPayload);
        }
      });

      const setupBasicScan = () => {
        const scanRoot = document.querySelector('[data-basic-scan]');
        const latestRoot = document.querySelector('[data-latest-scan]');
        const historyRoot = document.querySelector('[data-scan-history]');
        const historyDetailPanel = document.querySelector('[data-scan-history-detail]');
        if (!scanRoot) {
          return;
        }
        const scanParameters = scanRoot.querySelector('[data-basic-scan-parameters]');
        const runControls = scanRoot.querySelector('[data-basic-scan-run-controls]');
        const runButton = scanRoot.querySelector('[data-basic-scan-run]');
        const progressWrap = scanRoot.querySelector('[data-basic-scan-progress]');
        const progressFill = scanRoot.querySelector('[data-basic-scan-progress-fill]');
        const progressStatus = scanRoot.querySelector('[data-basic-scan-progress-status]');
        const progressHelper = scanRoot.querySelector('[data-basic-scan-progress-helper]');
        const progressLog = scanRoot.querySelector('[data-basic-scan-progress-log]');
        const stopButton = scanRoot.querySelector('[data-basic-scan-stop]');
        const buildScanElements = (prefix, root) => ({
          resultsWrap: root?.querySelector(`[data-${prefix}-results]`),
          summaryLead: root?.querySelector(`[data-${prefix}-summary-lead]`),
          summaryList: root?.querySelector(`[data-${prefix}-summary-list]`),
          detailedWrap: root?.querySelector(`[data-${prefix}-detailed]`),
          exportSummary: root?.querySelector(`[data-${prefix}-export-summary]`),
          exportDetailed: root?.querySelector(`[data-${prefix}-export-detailed]`),
          summarySection: root?.querySelector(`[data-${prefix}-summary-section]`),
          detailedSection: root?.querySelector(`[data-${prefix}-detailed-section]`),
          csvControls: root?.querySelector(`[data-${prefix}-csv-controls]`),
        });
        const latestResults = buildScanElements('latest-scan', latestRoot);
        const historyDetailRoot = historyDetailPanel?.querySelector('[data-scan-history-detail-results]');
        const historyDetailElements = buildScanElements('history-detail', historyDetailRoot);
        const historyElements = {
          table: historyRoot?.querySelector('[data-scan-history-table]'),
          body: historyRoot?.querySelector('[data-scan-history-body]'),
          empty: historyRoot?.querySelector('[data-scan-history-empty]'),
          list: historyRoot?.querySelector('[data-scan-history-list]'),
        };
        const historyCompareElements = {
          toggle: scanHistorySection?.querySelector('[data-scan-history-compare-toggle]'),
          cancel: scanHistorySection?.querySelector('[data-scan-history-compare-cancel]'),
          run: scanHistorySection?.querySelector('[data-scan-history-compare-run]'),
          close: scanHistorySection?.querySelector('[data-scan-history-compare-close]'),
          column: scanHistorySection?.querySelector('[data-scan-history-compare-column]'),
          panel: scanHistorySection?.querySelector('[data-scan-history-compare]'),
          download: scanHistorySection?.querySelector('[data-scan-history-compare-download]'),
          message: scanHistorySection?.querySelector('[data-scan-history-compare-message]'),
          summary: scanHistorySection?.querySelector('[data-scan-history-compare-summary]'),
          followers: scanHistorySection?.querySelector('[data-scan-history-compare-followers]'),
          followersBody: scanHistorySection?.querySelector(
            '[data-scan-history-compare-followers-body]'
          ),
          table: scanHistorySection?.querySelector('[data-scan-history-compare-table]'),
          body: scanHistorySection?.querySelector('[data-scan-history-compare-body]'),
        };
        const historyDetailMessage = historyDetailPanel?.querySelector(
          '[data-scan-history-detail-message]'
        );
        const historyDetailBackButton = historyDetailPanel?.querySelector('[data-scan-history-back]');
        const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        let activeScanId = null;
        let eventSource = null;
        let currentStage = 1;
        let watchdogTimer = null;
        let lastMessageAt = null;
        let hasStopped = false;
        let lastProgressSnapshot = null;
        let pollTimer = null;
        let pollActiveScanId = null;
        let pollInFlight = false;
        let pollStartAt = null;
        let etaMsFromServer = null;
        let etaMsLive = null;
        let etaTickInterval = null;
        let selectedHistoryScanId = null;
        let historyDetailRequestId = 0;
        let compareMode = false;
        let compareResultsView = false;
        let selectedCompareScanIds = [];
        let compareLoading = false;
        let compareError = null;
        let compareData = null;
        let compareRequestId = 0;
        let latestHistoryItems = [];
        const WATCHDOG_MS = 45000;
        const WATCHDOG_CHECK_MS = 5000;
        const compareColumnMediaQuery = window.matchMedia('(max-width: 640px)');
        let compareColumnListener = null;

        const setStage = (stage, scrollTarget) => {
          currentStage = stage;
          const showStage1 = stage === 1;
          const showStage2 = stage === 2;

          if (showStage1) {
            showSection(scanParameters);
            showSection(runControls);
            hideSection(progressWrap);
          }

          if (showStage2) {
            hideSection(scanParameters);
            hideSection(runControls);
            showSection(progressWrap);
          }

          const target =
            scrollTarget || (showStage1 ? scanParameters || scanRoot : progressWrap || scanRoot);
          scrollSectionToCenter(target);
        };
        basicScanStageController = { setStage, getStage: () => currentStage };

        const openBasicScanStage1 = () => {
          setStage(1, scanParameters || scanRoot);
        };

        const openBasicScanStage2 = () => {
          setStage(2, progressWrap || scanRoot);
        };

        const computeEtaMinutes = (etaMs) => {
          if (!Number.isFinite(etaMs)) {
            return null;
          }
          const clampedMs = Math.max(0, etaMs);
          if (clampedMs <= 0) {
            return null;
          }
          const minutes = Math.ceil(clampedMs / 60000);
          if (clampedMs > 0 && minutes < 1) {
            return 1;
          }
          return minutes;
        };

        const updateProgressHelper = (etaMsValue = null) => {
          if (!progressHelper) {
            return;
          }
          const minutes = computeEtaMinutes(etaMsValue);
          if (minutes !== null) {
            progressHelper.textContent = `Your scan is still in progress. Estimated time remaining: ${minutes} minutes. Refresh this page in ${minutes} minutes to see your scan results.`;
          } else {
            progressHelper.textContent =
              'Your scan is still in progress. Refresh this page in a few minutes to see your scan results.';
          }
        };

        const setEtaMsFromServer = (etaMs) => {
          if (Number.isFinite(etaMs)) {
            etaMsFromServer = Math.max(etaMs, 0);
            etaMsLive = etaMsFromServer;
          } else {
            etaMsFromServer = null;
            etaMsLive = null;
          }
          updateProgressHelper(etaMsLive);
        };

        const stopEtaTick = () => {
          if (etaTickInterval) {
            clearInterval(etaTickInterval);
            etaTickInterval = null;
          }
        };

        const startEtaTick = () => {
          if (etaTickInterval) {
            return;
          }
          etaTickInterval = setInterval(() => {
            if (!['queued', 'running'].includes(activeScanStatus)) {
              stopEtaTick();
              return;
            }
            if (!Number.isFinite(etaMsLive)) {
              return;
            }
            etaMsLive = Math.max(0, etaMsLive - 1000);
            updateProgressHelper(etaMsLive);
          }, 1000);
        };

        const syncEtaTicker = () => {
          if (['queued', 'running'].includes(activeScanStatus)) {
            startEtaTick();
          } else {
            stopEtaTick();
          }
        };

        const updateEta = (progress) => {
          const etaMs = progress?.eta_ms;
          if (Number.isFinite(etaMs)) {
            setEtaMsFromServer(etaMs);
            return;
          }
          updateProgressHelper(etaMsLive);
        };

        const buildProgressMessage = (message) => message || 'Scanning...';

        const setProgress = (current, total, message, progress = null) => {
          if (!progressWrap) {
            return;
          }
          lastProgressSnapshot = {
            completed_units: current,
            total_units: total,
            progress_pct: total ? Math.min((current / total) * 100, 100) : 0,
            eta_ms: progress?.eta_ms,
            eta_human: progress?.eta_human,
          };
          const percent = total ? Math.min((current / total) * 100, 100) : 0;
          if (progressFill) {
            progressFill.style.width = `${percent}%`;
          }
          if (progressStatus) {
            progressStatus.textContent = buildProgressMessage(message);
          }
          updateEta(progress);
        };

        const appendLog = (message) => {
          if (!progressLog || !message) {
            return;
          }
          const entry = document.createElement('div');
          entry.className = 'progress-log-entry';
          entry.textContent = message;
          progressLog.appendChild(entry);
          progressLog.scrollTop = progressLog.scrollHeight;
        };

        const hasResults = (scan) => {
          if (!scan || typeof scan !== 'object') {
            return false;
          }
          const summary = scan.summary || scan.results?.summary;
          if (Array.isArray(summary)) {
            return summary.length > 0;
          }
          const detailed = scan.detailed || scan.results?.detailed;
          if (detailed && typeof detailed === 'object') {
            return Object.keys(detailed).length > 0;
          }
          return false;
        };

        const logScanState = (scan, scanIdOverride = null) => {
          const scanId = scanIdOverride || scan?.scan_id || 'unknown';
          const status = scan?.status ?? 'unknown';
          const completedAt = scan?.completed_at || scan?.finished_at || null;
          const resultsSource = scan?.results || scan;
          const hasResultsValue = hasResults(resultsSource);
          if (typeof console !== 'undefined' && console.debug) {
            console.debug(
              '[UI_SCAN_STATE]',
              scanId,
              status,
              completedAt,
              hasResultsValue
            );
          }
          return { status, completedAt, hasResultsValue };
        };

        const isScanComplete = (scan, scanIdOverride = null) => {
          const { status, completedAt, hasResultsValue } = logScanState(
            scan,
            scanIdOverride
          );
          return status === 'completed' && Boolean(completedAt) && hasResultsValue;
        };

        const logSwitchLatest = (scanId, reason) => {
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[UI_SWITCH_LATEST]', scanId || 'none', reason);
          }
        };

        const applyProgressSnapshot = (progress, messageOverride) => {
          if (!progress || typeof progress !== 'object') {
            return;
          }
          const completed = progress.completed_units ?? 0;
          const total = progress.total_units ?? 0;
          const message = messageOverride || 'Scan in progress...';
          setProgress(completed, total, message, progress);
        };

        const setStopButtonVisible = (visible) => {
          if (!stopButton) {
            return;
          }
          stopButton.hidden = !visible;
          stopButton.disabled = !visible;
        };

        const stopPolling = () => {
          if (pollTimer) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
          pollStartAt = null;
          pollActiveScanId = null;
          pollInFlight = false;
        };

        const startCompletionPoll = (scanId) => {
          if (!scanId) {
            return;
          }
          stopPolling();
          pollActiveScanId = scanId;
          pollStartAt = Date.now();
          pollTimer = setInterval(async () => {
            if (!pollActiveScanId || pollInFlight) {
              return;
            }
            if (Date.now() - pollStartAt > 10 * 60 * 1000) {
              stopPolling();
              return;
            }
            pollInFlight = true;
            try {
              const response = await fetch(
                `/api/basic-rank-checker/scans/${pollActiveScanId}`
              );
              const data = await readErrorPayload(response);
              if (!response.ok) {
                throw new Error(
                  normalizeErrorMessage(data, 'Unable to check scan status.')
                );
              }
              if (data?.progress) {
                applyProgressSnapshot(data.progress);
              }
              activeScanStatus = data?.status || activeScanStatus;
              syncEtaTicker();
              if (isScanComplete(data, pollActiveScanId)) {
                await safeStop('completed', {
                  scanId: pollActiveScanId,
                  switchReason: 'poll_completed',
                });
                stopPolling();
              } else if (data?.status === 'failed') {
                appendLog('Scan failed.');
                await safeStop('scan failed');
                stopPolling();
              } else if (data?.status === 'cancelled') {
                appendLog('Scan cancelled.');
                await safeStop('cancelled', { scanId: pollActiveScanId });
                stopPolling();
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.debug) {
                console.debug('[basic-scan] polling error', error);
              }
            } finally {
              pollInFlight = false;
            }
          }, 5000);
        };

        const clearWatchdog = () => {
          if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
          }
          lastMessageAt = null;
        };

        const startWatchdog = () => {
          clearWatchdog();
          lastMessageAt = Date.now();
          watchdogTimer = setInterval(() => {
            if (!lastMessageAt) {
              return;
            }
            if (Date.now() - lastMessageAt > WATCHDOG_MS) {
              safeStop('timeout');
            }
          }, WATCHDOG_CHECK_MS);
        };

        const updateLastMessageAt = () => {
          lastMessageAt = Date.now();
        };

        const safeStop = async (reason, options = {}) => {
          if (hasStopped) {
            return;
          }
          hasStopped = true;
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          clearWatchdog();
          stopPolling();
          stopEtaTick();
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          setStopButtonVisible(false);

          const statusMessages = {
            completed: '✅ Dedicated scan completed.',
            timeout: 'Dedicated scan timed out. Please try again.',
            'connection error': 'Dedicated scan connection lost. Please try again.',
            'handler error': 'Dedicated scan failed. Please try again.',
            'scan failed': 'Dedicated scan failed. Please try again.',
            cancelled: 'Scan cancelled.',
          };
          const statusMessage = statusMessages[reason] || 'Basic Scan stopped.';
          const variant =
            reason === 'completed' || reason === 'cancelled' ? 'status-success' : 'status-error';

          if (reason === 'completed') {
            activeScanStatus = 'completed';
            syncEtaTicker();
            setProgress(options.total || 1, options.total || 1, 'Scan completed.', { eta_ms: 0 });
            setStage(1, scanParameters || scanRoot);
            logSwitchLatest(options.scanId || activeScanId, options.switchReason || 'completed');
            setActiveSection('latest', {
              skipScroll: true,
              skipFetch: true,
              allowRunningSwitch: true,
            });
            if (typeof loadLatestScan === 'function') {
              await loadLatestScan();
            }
          } else if (reason === 'cancelled') {
            activeScanStatus = 'cancelled';
            syncEtaTicker();
            if (lastProgressSnapshot) {
              setProgress(
                lastProgressSnapshot.completed_units || 0,
                lastProgressSnapshot.total_units || 1,
                statusMessage,
                lastProgressSnapshot
              );
            } else {
              setProgress(0, 1, statusMessage);
            }
            setStage(1, scanParameters || scanRoot);
          } else {
            activeScanStatus = 'failed';
            syncEtaTicker();
            setProgress(0, 1, statusMessage);
            setStage(1, scanParameters || scanRoot);
          }

          if (runButton) {
            runButton.disabled = false;
          }
          activeScanId = null;
          setStatus(statusMessage, variant);
        };

        const renderSummary = (scan, elements) => {
          const summaryLeadEl = elements?.summaryLead;
          const summaryListEl = elements?.summaryList;
          if (!summaryLeadEl || !summaryListEl) {
            return;
          }
          const follower = scan.follower_snapshot ?? '—';
          summaryLeadEl.textContent = `At ${formatTimestamp(
            scan.started_at
          )}, your playlist follower count was ${follower}.`;
          summaryListEl.innerHTML = '';
          (scan.summary || []).forEach((item) => {
            const row = document.createElement('div');
            row.className = `summary-row ${item.tracked_found_in_top20 ? '' : 'summary-row-missing'}`;
            const countryLabel = resolveMarketLabel(item.country);
            const { dateLabel, timeLabel } = formatSummaryDateParts(item.searched_at);
            const rankText = item.tracked_found_in_top20
              ? `your playlist rank was #${item.tracked_rank}.`
              : 'your playlist was not found in the top 20.';
            row.textContent = `On ${dateLabel} at ${timeLabel} in ${countryLabel} for ‘${item.keyword}’, ${rankText}`;
            summaryListEl.appendChild(row);
          });
        };

        const resolveFollowers = (result) => {
          const nestedFollowers =
            result.followers && typeof result.followers === 'object'
              ? result.followers.total
              : undefined;
          const nestedPlaylistFollowers =
            result.playlist && typeof result.playlist === 'object'
              ? result.playlist.followers || result.playlist.followers_total || result.playlist.follower_count
              : undefined;
          const nestedPlaylistFollowersTotal =
            nestedPlaylistFollowers && typeof nestedPlaylistFollowers === 'object'
              ? nestedPlaylistFollowers.total
              : undefined;
          const candidate =
            result.playlist_followers ??
            result.followers_total ??
            result.followers_count ??
            result.follower_count ??
            nestedFollowers ??
            nestedPlaylistFollowersTotal ??
            nestedPlaylistFollowers ??
            result.followers;
          return formatFollowersValue(candidate);
        };

        const renderDetailed = (scan, elements) => {
          const detailedWrapEl = elements?.detailedWrap;
          if (!detailedWrapEl) {
            return;
          }
          detailedWrapEl.innerHTML = '';
          const detailed = scan.detailed || {};
          const countryAccordions = [];
          Object.values(detailed).forEach((countryData) => {
            const countryCode = countryData.country;
            const countryDetails = document.createElement('details');
            countryDetails.className = 'accordion';
            const summary = document.createElement('summary');
            summary.textContent = `${flagEmoji(countryCode)} ${resolveMarketLabel(countryCode)}`;
            countryDetails.addEventListener('toggle', () => {
              if (!countryDetails.open) {
                return;
              }
              countryAccordions.forEach((openDetails) => {
                if (openDetails !== countryDetails) {
                  openDetails.open = false;
                }
              });
              requestAnimationFrame(() => {
                scrollSectionToCenter(countryDetails);
              });
            });
            countryDetails.appendChild(summary);
            countryAccordions.push(countryDetails);

            const keywordContainer = document.createElement('div');
            keywordContainer.className = 'accordion-body';
            const keywordAccordions = [];

            Object.entries(countryData.keywords || {}).forEach(([keyword, keywordData]) => {
              const keywordDetails = document.createElement('details');
              keywordDetails.className = 'accordion nested';
              const keywordSummary = document.createElement('summary');
              keywordSummary.textContent = `${keyword} · ${formatTimestamp(keywordData.searched_at)}`;
              keywordDetails.appendChild(keywordSummary);
              keywordDetails.addEventListener('toggle', () => {
                if (!keywordDetails.open) {
                  return;
                }
                keywordAccordions.forEach((openKeyword) => {
                  if (openKeyword !== keywordDetails) {
                    openKeyword.open = false;
                  }
                });
                requestAnimationFrame(() => {
                  scrollSectionToCenter(keywordDetails);
                });
              });

              const table = document.createElement('table');
              table.className = 'results-table';
              table.innerHTML = `
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Playlist</th>
                    <th>Owner</th>
                    <th>Followers</th>
                    <th>Songs</th>
                  </tr>
                </thead>
                <tbody></tbody>
              `;
              const tbody = table.querySelector('tbody');
              (keywordData.results || []).forEach((result) => {
                const followersValue = resolveFollowers(result);
                const row = document.createElement('tr');
                if (result.is_tracked_playlist) {
                  row.classList.add('tracked-highlight');
                }
                row.innerHTML = `
                  <td>${result.rank ?? '—'}</td>
                  <td>
                    ${
                      result.playlist_url
                        ? `<a href="${result.playlist_url}" target="_blank" rel="noopener noreferrer">${result.playlist_name || '—'}</a>`
                        : result.playlist_name || '—'
                    }
                  </td>
                  <td>${result.playlist_owner || '—'}</td>
                  <td>${followersValue}</td>
                  <td>${result.songs_count ?? '—'}</td>
                `;
                tbody.appendChild(row);
              });

              const tableScroll = document.createElement('div');
              tableScroll.className = 'table-scroll';
              tableScroll.appendChild(table);

              const keywordBody = document.createElement('div');
              keywordBody.className = 'accordion-body';
              keywordBody.appendChild(tableScroll);
              keywordDetails.appendChild(keywordBody);
              keywordContainer.appendChild(keywordDetails);
              keywordAccordions.push(keywordDetails);
            });

            countryDetails.appendChild(keywordContainer);
            detailedWrapEl.appendChild(countryDetails);
          });
        };

        const updateExportLinks = (scanId, startedAt, elements) => {
          const exportSummaryEl = elements?.exportSummary;
          const exportDetailedEl = elements?.exportDetailed;
          const timestamp = formatFileTimestamp(startedAt);
          const effectiveScanId = scanId || 'scan';
          const filenameBase = timestamp
            ? `${timestamp}_${effectiveScanId}`
            : `${effectiveScanId}`;
          const buildExportUrl = (path) => {
            const url = new URL(path, window.location.origin);
            if (timeZone) {
              url.searchParams.set('timezone', timeZone);
            }
            return `${url.pathname}${url.search}`;
          };
          if (exportSummaryEl) {
            exportSummaryEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/summary.csv`
            );
            exportSummaryEl.download = `${filenameBase}_summary.csv`;
          }
          if (exportDetailedEl) {
            exportDetailedEl.href = buildExportUrl(
              `/api/basic-rank-checker/scans/${scanId}/export/detailed.csv`
            );
            exportDetailedEl.download = `${filenameBase}_detailed.csv`;
          }
        };

        const renderScanResults = (scan, elements, scanId) => {
          if (!scan || typeof scan !== 'object') {
            return;
          }
          renderSummary(scan, elements);
          renderDetailed(scan, elements);
          if (elements?.summaryList) {
            elements.summaryList.hidden = false;
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = false;
          }
          if (elements?.csvControls) {
            showSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
          const startedAt =
            scan.started_at || scan.searched_at || scan.summary?.[0]?.searched_at;
          updateExportLinks(scanId, startedAt, elements);
        };

        const showEmptyState = (elements, message) => {
          if (elements?.summaryLead) {
            elements.summaryLead.textContent = message;
            elements.summaryLead.hidden = false;
          }
          if (elements?.summaryList) {
            elements.summaryList.innerHTML = '';
            elements.summaryList.hidden = true;
          }
          if (elements?.detailedWrap) {
            elements.detailedWrap.innerHTML = '';
          }
          if (elements?.detailedSection) {
            elements.detailedSection.hidden = true;
          }
          if (elements?.csvControls) {
            hideSection(elements.csvControls);
          }
          if (elements?.resultsWrap) {
            showSection(elements.resultsWrap);
          }
        };

        const setHistoryDetailMessage = (message, { isError = false } = {}) => {
          if (!historyDetailMessage) {
            return;
          }
          historyDetailMessage.textContent = message || '';
          historyDetailMessage.hidden = !message;
          historyDetailMessage.classList.toggle('is-error', Boolean(message) && isError);
        };

        const clearHistoryDetailResults = () => {
          if (!historyDetailElements) {
            return;
          }
          if (historyDetailElements.summaryLead) {
            historyDetailElements.summaryLead.textContent = '';
            historyDetailElements.summaryLead.hidden = false;
          }
          if (historyDetailElements.summaryList) {
            historyDetailElements.summaryList.innerHTML = '';
            historyDetailElements.summaryList.hidden = true;
          }
          if (historyDetailElements.detailedWrap) {
            historyDetailElements.detailedWrap.innerHTML = '';
          }
          if (historyDetailElements.detailedSection) {
            historyDetailElements.detailedSection.hidden = true;
          }
          if (historyDetailElements.csvControls) {
            hideSection(historyDetailElements.csvControls);
          }
          if (historyDetailElements.resultsWrap) {
            historyDetailElements.resultsWrap.hidden = true;
          }
        };

        const setHistoryCompareMessage = (message, { isError = false } = {}) => {
          if (!historyCompareElements.message) {
            return;
          }
          historyCompareElements.message.textContent = message || '';
          historyCompareElements.message.hidden = !message;
          historyCompareElements.message.classList.toggle('is-error', Boolean(message) && isError);
        };

        const clearHistoryCompareResults = () => {
          if (historyCompareElements.summary) {
            historyCompareElements.summary.innerHTML = '';
          }
          if (historyCompareElements.followersBody) {
            historyCompareElements.followersBody.innerHTML = '';
          }
          if (historyCompareElements.followers) {
            historyCompareElements.followers.hidden = true;
          }
          if (historyCompareElements.body) {
            historyCompareElements.body.innerHTML = '';
          }
          if (historyCompareElements.table) {
            historyCompareElements.table.hidden = true;
          }
        };

        const showHistoryComparePanel = () => {
          if (!historyCompareElements.panel) {
            return;
          }
          historyCompareElements.panel.hidden = false;
          historyCompareElements.panel.classList.add('is-active');
        };

        const hideHistoryComparePanel = () => {
          if (!historyCompareElements.panel) {
            return;
          }
          historyCompareElements.panel.classList.remove('is-active');
          historyCompareElements.panel.hidden = true;
        };

        const showHistoryDetailPanel = () => {
          if (!historyDetailPanel) {
            return;
          }
          historyDetailPanel.hidden = false;
          historyDetailPanel.classList.add('is-active');
        };

        const hideHistoryDetailPanel = () => {
          if (!historyDetailPanel) {
            return;
          }
          historyDetailPanel.classList.remove('is-active');
          historyDetailPanel.hidden = true;
        };

        const setElementVisibility = (element, isVisible) => {
          if (!element) {
            return;
          }
          element.hidden = !isVisible;
          element.style.display = isVisible ? '' : 'none';
        };

        const createScanHistoryCell = (value, className = '') => {
          const cell = document.createElement('td');
          if (className) {
            cell.classList.add(className);
          }
          cell.textContent = value || '—';
          return cell;
        };

        const createScanHistoryEllipsisCell = (value, className = '') => {
          const cell = document.createElement('td');
          if (className) {
            cell.classList.add(className);
          }
          const span = document.createElement('span');
          span.classList.add('scan-history-ellipsis');
          const textValue = value || '—';
          span.textContent = textValue;
          span.title = textValue;
          cell.appendChild(span);
          return cell;
        };

        const applyCompareColumnPlacement = () => {
          if (!compareMode || !historyElements.body || !historyElements.table) {
            return;
          }
          const headerRow = historyElements.table.querySelector('thead tr');
          const compareHeader = historyCompareElements.column;
          const isMobile = compareColumnMediaQuery.matches;
          if (headerRow && compareHeader) {
            if (isMobile) {
              headerRow.prepend(compareHeader);
            } else {
              headerRow.appendChild(compareHeader);
            }
          }
          historyElements.body.querySelectorAll('tr').forEach((row) => {
            const compareCell = row.querySelector('.scan-history-compare-cell');
            if (!compareCell) {
              return;
            }
            if (isMobile) {
              row.insertBefore(compareCell, row.firstElementChild);
            } else {
              row.appendChild(compareCell);
            }
          });
        };

        const enableCompareColumnListener = () => {
          if (compareColumnListener) {
            return;
          }
          compareColumnListener = () => applyCompareColumnPlacement();
          compareColumnMediaQuery.addEventListener('change', compareColumnListener);
        };

        const disableCompareColumnListener = () => {
          if (!compareColumnListener) {
            return;
          }
          compareColumnMediaQuery.removeEventListener('change', compareColumnListener);
          compareColumnListener = null;
        };

        const renderCompareControls = () => {
          const compareReady = compareMode && selectedCompareScanIds.length === 2 && !compareLoading;
          if (historyCompareElements.toggle) {
            historyCompareElements.toggle.classList.toggle('is-active', compareMode);
            historyCompareElements.toggle.setAttribute('aria-pressed', String(compareMode));
            setElementVisibility(
              historyCompareElements.toggle,
              !compareMode && !compareResultsView
            );
          }
          if (historyCompareElements.cancel) {
            setElementVisibility(historyCompareElements.cancel, compareMode && !compareResultsView);
          }
          if (historyCompareElements.run) {
            setElementVisibility(historyCompareElements.run, compareMode && !compareResultsView);
            historyCompareElements.run.disabled = !compareReady;
            historyCompareElements.run.classList.toggle('compare-btn-enabled', compareReady);
            historyCompareElements.run.classList.toggle('compare-btn-disabled', !compareReady);
            historyCompareElements.run.style.pointerEvents = compareReady ? 'auto' : 'none';
            historyCompareElements.run.style.cursor = compareReady ? 'pointer' : 'not-allowed';
          }
          if (historyCompareElements.close) {
            setElementVisibility(historyCompareElements.close, compareResultsView);
          }
          if (historyCompareElements.column) {
            setElementVisibility(historyCompareElements.column, compareMode && !compareResultsView);
          }
          if (historyCompareElements.download) {
            const hasRows = Array.isArray(compareData?.rows) && compareData.rows.length > 0;
            setElementVisibility(historyCompareElements.download, compareResultsView);
            historyCompareElements.download.disabled = compareLoading || !hasRows;
          }
        };

        const applyCompareSelectionState = () => {
          if (!historyElements.body) {
            return;
          }
          const limitReached = selectedCompareScanIds.length >= 2;
          const checkboxes = historyElements.body.querySelectorAll('[data-scan-history-checkbox]');
          checkboxes.forEach((checkbox) => {
            const isSelected = selectedCompareScanIds.includes(checkbox.value);
            checkbox.checked = isSelected;
            checkbox.disabled = compareLoading || (!isSelected && limitReached);
          });
        };

        const resetCompareState = ({ skipScroll = false } = {}) => {
          compareMode = false;
          compareResultsView = false;
          selectedCompareScanIds = [];
          compareLoading = false;
          compareError = null;
          compareData = null;
          compareRequestId += 1;
          disableCompareColumnListener();
          setHistoryCompareMessage('');
          clearHistoryCompareResults();
          hideHistoryComparePanel();
          if (typeof resetHistoryDetail === 'function') {
            resetHistoryDetail({ skipScroll: true, scrollTarget: scanHistorySection || historyRoot });
          }
          if (historyElements.list) {
            showSection(historyElements.list);
          }
          renderScanHistory(latestHistoryItems);
          renderCompareControls();
          applyCompareSelectionState();
          if (!skipScroll) {
            scrollSectionToCenter(scanHistorySection || historyRoot);
          }
        };

        const enterCompareMode = ({ skipScroll = false } = {}) => {
          compareMode = true;
          compareResultsView = false;
          selectedCompareScanIds = [];
          compareLoading = false;
          compareError = null;
          compareData = null;
          compareRequestId += 1;
          enableCompareColumnListener();
          setHistoryCompareMessage('');
          clearHistoryCompareResults();
          hideHistoryComparePanel();
          if (typeof resetHistoryDetail === 'function') {
            resetHistoryDetail({ skipScroll: true, scrollTarget: scanHistorySection || historyRoot });
          }
          if (historyElements.list) {
            showSection(historyElements.list);
          }
          renderScanHistory(latestHistoryItems);
          renderCompareControls();
          applyCompareSelectionState();
          if (!skipScroll) {
            scrollSectionToCenter(scanHistorySection || historyRoot);
          }
        };

        const renderCompareSummaryCard = (scan, label) => {
          const scanDate = formatTimestamp(scan?.created_at || scan?.started_at || scan?.finished_at);
          const statusLabel = formatScanHistoryStatus(scan?.status);
          const countriesCount = Array.isArray(scan?.scanned_countries)
            ? scan.scanned_countries.length
            : '—';
          const keywordsCount = Array.isArray(scan?.scanned_keywords)
            ? scan.scanned_keywords.length
            : '—';

          return `
            <div class="scan-history-compare-card">
              <h4>${label}</h4>
              <dl>
                <div>
                  <dt>Scan date</dt>
                  <dd>${scanDate}</dd>
                </div>
                <div>
                  <dt>Status</dt>
                  <dd>${statusLabel}</dd>
                </div>
                <div>
                  <dt>Countries</dt>
                  <dd>${countriesCount}</dd>
                </div>
                <div>
                  <dt>Keywords</dt>
                  <dd>${keywordsCount}</dd>
                </div>
              </dl>
            </div>
          `;
        };

        const formatSummaryDeltaCount = (value, direction) => {
          const safeValue = Number.isFinite(value) ? value : 0;
          if (direction === 'up') {
            return `<span class="delta-up">↑${safeValue}</span>`;
          }
          if (direction === 'down') {
            return `<span class="delta-down">↓${safeValue}</span>`;
          }
          return `<span class="delta-neutral">${safeValue}</span>`;
        };

        const renderCompareOverviewCard = ({
          followersChange,
          improvedCount,
          worsenedCount,
          unchangedCount,
        }) => `
          <div class="scan-history-compare-card">
            <h4>Summary</h4>
            <dl>
              <div>
                <dt>Followers</dt>
                <dd>${followersChange}</dd>
              </div>
              <div>
                <dt>Improved positions</dt>
                <dd>${formatSummaryDeltaCount(improvedCount, 'up')}</dd>
              </div>
              <div>
                <dt>Declined positions</dt>
                <dd>${formatSummaryDeltaCount(worsenedCount, 'down')}</dd>
              </div>
              <div>
                <dt>Unchanged</dt>
                <dd>${formatSummaryDeltaCount(unchangedCount, 'flat')}</dd>
              </div>
            </dl>
          </div>
        `;

        const toNumber = (value) => {
          const coerced = Number(value);
          return Number.isFinite(coerced) ? coerced : null;
        };

        const formatCompareRank = (value) => {
          if (value === null || typeof value === 'undefined') {
            return '—';
          }
          return Number.isFinite(value) ? value : '—';
        };

        const formatCompareCount = (value) => {
          if (value === null || typeof value === 'undefined') {
            return '—';
          }
          return Number.isFinite(value) ? value.toLocaleString() : '—';
        };

        const formatFollowerDelta = (value) => {
          if (!Number.isFinite(value)) {
            return '<span class="delta-flat">—</span>';
          }
          if (value > 0) {
            return `<span class="delta-up">↑ ${value.toLocaleString()}</span>`;
          }
          if (value < 0) {
            return `<span class="delta-down">↓ ${Math.abs(value).toLocaleString()}</span>`;
          }
          return '<span class="delta-flat">0</span>';
        };

        const formatPositionChange = (rankA, rankB) => {
          if (!Number.isFinite(rankA) || !Number.isFinite(rankB)) {
            return { text: '—', className: 'delta-neutral' };
          }
          const delta = rankB - rankA;
          if (delta > 0) {
            return { text: `↑ ${Math.abs(delta)}`, className: 'delta-up' };
          }
          if (delta < 0) {
            return { text: `↓ ${Math.abs(delta)}`, className: 'delta-down' };
          }
          return { text: '—', className: 'delta-neutral' };
        };

        const formatPositionChangeCsv = (rankA, rankB) => {
          if (!Number.isFinite(rankA) || !Number.isFinite(rankB)) {
            return '';
          }
          const delta = rankA - rankB;
          if (delta < 0) {
            return `UP ${Math.abs(delta)}`;
          }
          if (delta > 0) {
            return `DOWN ${Math.abs(delta)}`;
          }
          return 'UNCHANGED';
        };

        const escapeCsvValue = (value) => {
          if (value === null || typeof value === 'undefined') {
            return '';
          }
          const stringValue = String(value);
          if (/["\n,]/.test(stringValue)) {
            return `"${stringValue.replace(/"/g, '""')}"`;
          }
          return stringValue;
        };

        const buildComparisonCsv = (comparison) => {
          if (!comparison?.rows || !Array.isArray(comparison.rows)) {
            return null;
          }
          const followerA = toNumber(comparison.scanA?.follower_snapshot);
          const followerB = toNumber(comparison.scanB?.follower_snapshot);
          const followerChange =
            Number.isFinite(followerA) && Number.isFinite(followerB)
              ? followerA - followerB
              : '';
          const header = [
            'country',
            'keyword',
            'rank_a',
            'rank_b',
            'position_change',
            'followers_a',
            'followers_b',
            'followers_change',
          ];
          const lines = comparison.rows.map((row) => {
            const rankA = Number.isFinite(row.rankA) ? row.rankA : '';
            const rankB = Number.isFinite(row.rankB) ? row.rankB : '';
            const countryLabel = resolveMarketLabel(row.country) || row.country || '';
            return [
              countryLabel,
              row.keyword || '',
              rankA,
              rankB,
              formatPositionChangeCsv(rankA, rankB),
              Number.isFinite(followerA) ? followerA : '',
              Number.isFinite(followerB) ? followerB : '',
              followerChange,
            ]
              .map(escapeCsvValue)
              .join(',');
          });
          return [header.join(','), ...lines].join('\n');
        };

        const downloadComparisonCsv = () => {
          if (!compareData) {
            return;
          }
          const csvBody = buildComparisonCsv(compareData);
          if (!csvBody) {
            return;
          }
          const trackedPlaylistId = resolveTrackedPlaylistId() || 'playlist';
          const scanAId = compareData.scanA?.scan_id || selectedCompareScanIds[0] || 'scanA';
          const scanBId = compareData.scanB?.scan_id || selectedCompareScanIds[1] || 'scanB';
          const filename = `comparison_${trackedPlaylistId}_${scanAId}_vs_${scanBId}.csv`;
          const blob = new Blob([csvBody], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(url);
        };

        const getScanTimestamp = (scan) => {
          const rawTimestamp = scan?.created_at || scan?.started_at || scan?.finished_at;
          const parsed = rawTimestamp ? Date.parse(rawTimestamp) : Number.NaN;
          return Number.isFinite(parsed) ? parsed : null;
        };

        const renderHistoryComparison = (scanA, scanB) => {
          if (!historyCompareElements.summary || !historyCompareElements.body) {
            return [];
          }
          const followerA = toNumber(scanA?.follower_snapshot);
          const followerB = toNumber(scanB?.follower_snapshot);
          const followerChange =
            Number.isFinite(followerA) && Number.isFinite(followerB)
              ? followerA - followerB
              : null;

          const comparisonMap = new Map();
          const ingestSummary = (scan, label) => {
            const summary = Array.isArray(scan?.summary) ? scan.summary : [];
            summary.forEach((entry) => {
              const countryCode = entry?.country || '—';
              const keyword = entry?.keyword || '—';
              const key = `${countryCode}|||${keyword}`;
              if (!comparisonMap.has(key)) {
                comparisonMap.set(key, { country: countryCode, keyword });
              }
              const row = comparisonMap.get(key);
              row[`rank${label}`] = entry?.tracked_rank ?? null;
            });
          };
          ingestSummary(scanA, 'A');
          ingestSummary(scanB, 'B');

          const rows = Array.from(comparisonMap.values()).sort((first, second) => {
            const countryA = resolveMarketLabel(first.country) || '';
            const countryB = resolveMarketLabel(second.country) || '';
            if (countryA !== countryB) {
              return countryA.localeCompare(countryB);
            }
            return (first.keyword || '').localeCompare(second.keyword || '');
          });

          historyCompareElements.body.innerHTML = '';
          let improvedCount = 0;
          let worsenedCount = 0;
          let unchangedCount = 0;

          rows.forEach((row) => {
            const rankA = Number.isFinite(row.rankA) ? row.rankA : null;
            const rankB = Number.isFinite(row.rankB) ? row.rankB : null;
            if (Number.isFinite(rankA) && Number.isFinite(rankB)) {
              const delta = rankB - rankA;
              if (delta > 0) {
                improvedCount += 1;
              } else if (delta < 0) {
                worsenedCount += 1;
              } else {
                unchangedCount += 1;
              }
            }
          });

          historyCompareElements.summary.innerHTML = `
            ${renderCompareOverviewCard({
              followersChange: formatFollowerDelta(followerChange),
              improvedCount,
              worsenedCount,
              unchangedCount,
            })}
            ${renderCompareSummaryCard(scanA, 'Scan A (newer)')}
            ${renderCompareSummaryCard(scanB, 'Scan B (older)')}
          `;

          if (historyCompareElements.followersBody) {
            historyCompareElements.followersBody.innerHTML = `
              <tr>
                <td>Followers</td>
                <td>${formatCompareCount(followerA)}</td>
                <td>${formatCompareCount(followerB)}</td>
                <td>${formatFollowerDelta(followerChange)}</td>
              </tr>
            `;
          }
          if (historyCompareElements.followers) {
            historyCompareElements.followers.hidden = false;
          }
          if (!rows.length) {
            setHistoryCompareMessage('No summary data available to compare.');
            if (historyCompareElements.table) {
              historyCompareElements.table.hidden = true;
            }
            return rows;
          }

          rows.forEach((row) => {
            const rankA = Number.isFinite(row.rankA) ? row.rankA : null;
            const rankB = Number.isFinite(row.rankB) ? row.rankB : null;
            const positionChange = formatPositionChange(rankA, rankB);
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${resolveMarketLabel(row.country) || '—'}</td>
              <td>${row.keyword || '—'}</td>
              <td>${formatCompareRank(rankA)}</td>
              <td>${formatCompareRank(rankB)}</td>
              <td class="${positionChange.className}">${positionChange.text}</td>
            `;
            historyCompareElements.body.appendChild(tr);
          });

          if (historyCompareElements.table) {
            historyCompareElements.table.hidden = false;
          }
          return rows;
        };

        resetHistoryDetail = ({ skipScroll = false, scrollTarget = null } = {}) => {
          selectedHistoryScanId = null;
          historyDetailRequestId += 1;
          setHistoryDetailMessage('');
          clearHistoryDetailResults();
          hideHistoryDetailPanel();
          if (historyElements.list) {
            showSection(historyElements.list);
          }
          if (!skipScroll) {
            scrollSectionToCenter(scrollTarget || scanHistorySection || historyRoot);
          }
        };

        resetHistoryCompare = ({ skipScroll = false } = {}) => {
          resetCompareState({ skipScroll });
        };

        const connectEventStream = (scanId) => {
          if (!scanId) {
            return;
          }
          activeScanId = scanId;
          activeScanStatus = activeScanStatus || 'running';
          syncEtaTicker();
          setStopButtonVisible(true);
          if (eventSource) {
            eventSource.close();
          }
          const eventsUrl = `/api/basic-rank-checker/scans/${scanId}/events`;
          eventSource = new EventSource(eventsUrl);
          startWatchdog();
          startCompletionPoll(scanId);
          eventSource.onmessage = async (event) => {
            try {
              updateLastMessageAt();
              const rawText = event?.data ?? '';
              let payload = null;
              try {
                payload = JSON.parse(rawText);
              } catch (error) {
                payload = null;
              }
              if (payload?.type === 'completed' || payload?.type === 'scan_completed') {
                await safeStop('completed', {
                  scanId: activeScanId,
                  total: payload?.total,
                  switchReason: 'terminal_event',
                });
                return;
              }
              if (payload?.type === 'cancelled') {
                await safeStop('cancelled', { scanId: activeScanId });
                return;
              }
              if (payload?.type === 'progress') {
                activeScanStatus = 'running';
                syncEtaTicker();
                setProgress(payload.step, payload.total, payload.message, payload);
                appendLog(payload.message);
              }
              if (payload?.type === 'error' || payload?.type === 'failed') {
                appendLog(payload.message || 'Scan failed.');
                await safeStop('scan failed');
              }
            } catch (error) {
              if (typeof console !== 'undefined' && console.error) {
                console.error('[basic-scan] event handling failed', error);
              }
              await safeStop('handler error');
            }
          };
          eventSource.onerror = (error) => {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] connection error', error);
            }
            safeStop('connection error');
          };
        };

        const resolveTrackedPlaylistId = () => {
          const datasetId = scanRoot?.dataset?.trackedPlaylistId;
          const latestDatasetId = latestRoot?.dataset?.trackedPlaylistId;
          if (datasetId) {
            return datasetId;
          }
          if (latestDatasetId) {
            return latestDatasetId;
          }
          const pathId = window.location.pathname.split('/').filter(Boolean).pop();
          if (!pathId && typeof console !== 'undefined' && console.debug) {
            console.debug('[basic-scan] tracked playlist id missing for payload');
          }
          return pathId || '';
        };

        const cancelActiveScan = async () => {
          if (!activeScanId) {
            return;
          }
          const scanId = activeScanId;
          const cancelPromise = fetch(
            `/api/basic-rank-checker/scans/${scanId}/cancel`,
            { method: 'POST' }
          ).catch(() => null);
          await safeStop('cancelled', { scanId });
          await cancelPromise;
        };

        const fetchActiveScan = async ({ trackedPlaylistId } = {}) => {
          const playlistId = trackedPlaylistId ?? resolveTrackedPlaylistId();
          const url = new URL('/api/basic-rank-checker/scans/active', window.location.origin);
          if (playlistId) {
            url.searchParams.set('tracked_playlist_id', playlistId);
          }
          const response = await fetch(`${url.pathname}${url.search}`);
          const data = await readErrorPayload(response);
          if (response.status === 404) {
            return null;
          }
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load active scan.'));
          }
          return data;
        };

        const resumeActiveScan = (activeScan) => {
          if (!activeScan?.scan_id) {
            return;
          }
          activeScanId = activeScan.scan_id;
          activeScanStatus = activeScan.status || 'running';
          syncEtaTicker();
          setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          openBasicScanStage2();
          applyProgressSnapshot(activeScan.progress, 'Scan in progress...');
          setStopButtonVisible(true);
          connectEventStream(activeScan.scan_id);
        };

        const startScan = async ({ source } = {}) => {
          const trackedPlaylistId = resolveTrackedPlaylistId();
          if (source !== 'button_click') {
            if (typeof console !== 'undefined' && console.warn) {
              console.warn('[START_SCAN_BLOCKED]', { source });
            }
            return;
          }
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[START_SCAN_CALLED] source=button_click', { trackedPlaylistId });
          }
          if (!runButton) {
            return;
          }

          const activeScan = await fetchActiveScan({ trackedPlaylistId }).catch(() => null);
          if (activeScan?.scan_id) {
            if (typeof console !== 'undefined' && console.debug) {
              console.debug('[START_SCAN_SKIPPED] active scan already running', {
                scanId: activeScan.scan_id,
                trackedPlaylistId,
              });
            }
            resumeActiveScan(activeScan);
            setStatus('A scan is already running for this playlist. Resuming…', 'status-loading');
            return;
          }

          hasStopped = false;
          runButton.disabled = true;
          if (progressLog) {
            progressLog.innerHTML = '';
          }
          lastProgressSnapshot = null;
          setEtaMsFromServer(null);
          setStopButtonVisible(true);
          setProgress(0, 0, 'Starting scan…');
          let scanStarted = false;

          try {
            const response = await fetch('/api/basic-rank-checker/scans', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tracked_playlist_id: trackedPlaylistId }),
            });
            const data = await readErrorPayload(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to start scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to start scan.');
            }
            activeScanId = data.scan_id;
            scanStarted = Boolean(activeScanId);
            activeScanStatus = 'running';
            syncEtaTicker();
            connectEventStream(activeScanId);
            setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[basic-scan] start failed', error);
            }
            setStage(1);
            runButton.disabled = false;
            setStopButtonVisible(false);
            setStatus(normalizeErrorMessage(error, 'Failed to start scan.'), 'status-error');
          } finally {
            if (!scanStarted && runButton.disabled) {
              runButton.disabled = false;
              if (basicScanStageController?.getStage?.() === 2) {
                setStage(1);
              }
            }
          }
        };

        loadLatestScan = async () => {
          if (!latestRoot) {
            return;
          }
          const trackedPlaylistId = resolveTrackedPlaylistId();

          try {
            const url = new URL(
              '/api/basic-rank-checker/scans/latest-completed',
              window.location.origin
            );
            if (trackedPlaylistId) {
              url.searchParams.set('tracked_playlist_id', trackedPlaylistId);
            }
            const response = await fetch(`${url.pathname}${url.search}`);
            const data = await readErrorPayload(response);
            if (response.status === 404) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to load latest scan.'));
            }
            if (!data || typeof data !== 'object' || !data.scan_id) {
              throw new Error('Failed to load latest scan.');
            }
            const resultsPayload = data.results || {};
            if (!hasResults(resultsPayload)) {
              showEmptyState(latestResults, 'No completed scans yet.');
              return;
            }
            renderScanResults(resultsPayload, latestResults, data.scan_id);
          } catch (error) {
            setStatus(normalizeErrorMessage(error, 'Failed to load latest scan.'), 'status-error');
          }
        };

        const formatScanHistoryStatus = (value) => {
          if (!value) {
            return '—';
          }
          return String(value).replace(/_/g, ' ');
        };

        const fetchScanDetail = async (scanId) => {
          if (!scanId) {
            return null;
          }
          const response = await fetch(`/api/basic-rank-checker/scans/${scanId}`);
          const data = await readErrorPayload(response);
          if (!response.ok) {
            throw new Error(normalizeErrorMessage(data, 'Failed to load scan details.'));
          }
          return data;
        };

        const openHistoryDetail = async (scanId) => {
          if (!scanId || !historyDetailPanel) {
            return;
          }
          selectedHistoryScanId = scanId;
          historyDetailRequestId += 1;
          const requestId = historyDetailRequestId;
          if (historyElements.list) {
            hideSection(historyElements.list);
          }
          showHistoryDetailPanel();
          clearHistoryDetailResults();
          setHistoryDetailMessage('Loading scan details…');
          historyDetailPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });

          try {
            const data = await fetchScanDetail(scanId);
            if (requestId !== historyDetailRequestId) {
              return;
            }
            const resultsPayload = data?.results || data;
            if (!resultsPayload || !hasResults(resultsPayload)) {
              showEmptyState(
                historyDetailElements,
                'No scan results were found for this run.'
              );
              setHistoryDetailMessage('No scan results found for this run.');
              return;
            }
            renderScanResults(resultsPayload, historyDetailElements, data?.scan_id || scanId);
            setHistoryDetailMessage('');
          } catch (error) {
            if (requestId !== historyDetailRequestId) {
              return;
            }
            setHistoryDetailMessage(
              normalizeErrorMessage(error, 'Unable to load scan details.'),
              { isError: true }
            );
          }
        };

        const openHistoryCompare = async () => {
          if (selectedCompareScanIds.length !== 2) {
            return;
          }
          compareLoading = true;
          compareError = null;
          compareResultsView = true;
          compareRequestId += 1;
          const requestId = compareRequestId;
          renderCompareControls();
          if (historyElements.list) {
            hideSection(historyElements.list);
          }
          hideHistoryDetailPanel();
          showHistoryComparePanel();
          clearHistoryCompareResults();
          setHistoryCompareMessage('Loading comparison results…');
          if (historyCompareElements.panel) {
            historyCompareElements.panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }

          try {
            const [firstScan, secondScan] = await Promise.all(
              selectedCompareScanIds.map((scanId) => fetchScanDetail(scanId))
            );
            if (requestId !== compareRequestId) {
              return;
            }
            const firstTimestamp = getScanTimestamp(firstScan);
            const secondTimestamp = getScanTimestamp(secondScan);
            let scanA = firstScan;
            let scanB = secondScan;
            if (firstTimestamp === null && secondTimestamp !== null) {
              scanA = secondScan;
              scanB = firstScan;
            } else if (
              firstTimestamp !== null &&
              secondTimestamp !== null &&
              firstTimestamp < secondTimestamp
            ) {
              scanA = secondScan;
              scanB = firstScan;
            }
            const rows = renderHistoryComparison(scanA, scanB);
            compareData = { scanA, scanB, rows };
            setHistoryCompareMessage('');
          } catch (error) {
            if (requestId !== compareRequestId) {
              return;
            }
            compareError = error;
            setHistoryCompareMessage(
              normalizeErrorMessage(error, 'Unable to load comparison results.'),
              { isError: true }
            );
          } finally {
            if (requestId === compareRequestId) {
              compareLoading = false;
              renderCompareControls();
              applyCompareSelectionState();
            }
          }
        };

        const renderScanHistory = (items) => {
          if (!historyElements.body || !historyElements.table || !historyElements.empty) {
            return;
          }
          latestHistoryItems = Array.isArray(items) ? items : [];
          historyElements.body.innerHTML = '';
          if (!latestHistoryItems.length) {
            selectedCompareScanIds = [];
            renderCompareControls();
            historyElements.empty.textContent = 'No scan history yet for this playlist.';
            showSection(historyElements.empty);
            hideSection(historyElements.table);
            return;
          }
          hideSection(historyElements.empty);
          showSection(historyElements.table);
          renderCompareControls();
          latestHistoryItems.forEach((item) => {
            const row = document.createElement('tr');
            const countries = (item.countries || [])
              .map((country) => resolveMarketLabel(country))
              .join(', ');
            const keywords = (item.keywords || []).join(', ');
            const scanDate = formatTimestamp(item.created_at || item.started_at || item.finished_at);
            const scanId = item.scan_id;
            row.classList.add('scan-history-row');
            if (compareMode) {
              row.classList.add('is-disabled');
            }
            row.dataset.scanId = scanId || '';
            if (!compareMode) {
              row.setAttribute('role', 'button');
              row.tabIndex = 0;
            }
            row.append(
              createScanHistoryEllipsisCell(countries || '—', 'scan-history-col-country'),
              createScanHistoryEllipsisCell(keywords || '—', 'scan-history-col-keyword'),
              createScanHistoryCell(formatScanHistoryStatus(item.status), 'scan-history-col-status'),
              createScanHistoryCell(scanDate, 'scan-history-col-date')
            );
            if (compareMode) {
              const compareCell = document.createElement('td');
              compareCell.classList.add('scan-history-compare-cell');
              const checkbox = document.createElement('input');
              checkbox.type = 'checkbox';
              checkbox.classList.add('scan-history-checkbox');
              checkbox.setAttribute('data-scan-history-checkbox', '');
              checkbox.value = scanId || '';
              compareCell.appendChild(checkbox);
              row.appendChild(compareCell);
              if (checkbox) {
                checkbox.addEventListener('change', (event) => {
                  if (!scanId) {
                    event.target.checked = false;
                    return;
                  }
                  const isChecked = event.target.checked;
                  const alreadySelected = selectedCompareScanIds.includes(scanId);
                  if (isChecked) {
                    if (alreadySelected) {
                      return;
                    }
                    if (selectedCompareScanIds.length >= 2) {
                      event.target.checked = false;
                      return;
                    }
                    selectedCompareScanIds = [...selectedCompareScanIds, scanId];
                  } else {
                    selectedCompareScanIds = selectedCompareScanIds.filter(
                      (value) => value !== scanId
                    );
                  }
                  renderCompareControls();
                  applyCompareSelectionState();
                });
              }
            } else {
              const activateRow = () => {
                if (!scanId || compareMode) {
                  return;
                }
                openHistoryDetail(scanId);
              };
              row.addEventListener('click', activateRow);
              row.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  activateRow();
                }
              });
            }
            historyElements.body.appendChild(row);
          });
          renderCompareControls();
          applyCompareSelectionState();
          applyCompareColumnPlacement();
        };

        loadScanHistory = async () => {
          if (!historyRoot) {
            return;
          }
          resetCompareState({ skipScroll: true });
          renderCompareControls();
          const trackedPlaylistId = resolveTrackedPlaylistId();
          if (!trackedPlaylistId) {
            renderScanHistory([]);
            return;
          }
          try {
            const url = new URL('/api/basic-rank-checker/scans/history', window.location.origin);
            url.searchParams.set('tracked_playlist_id', trackedPlaylistId);
            const response = await fetch(`${url.pathname}${url.search}`);
            const data = await readErrorPayload(response);
            if (!response.ok) {
              throw new Error(normalizeErrorMessage(data, 'Failed to load scan history.'));
            }
            const items = Array.isArray(data?.items) ? data.items : [];
            const trackedItems = items.filter((item) => item?.is_tracked_playlist);
            renderScanHistory(trackedItems);
          } catch (error) {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[scan-history] load failed', error);
            }
            setStatus(
              normalizeErrorMessage(error, 'Failed to load scan history.'),
              'status-error'
            );
          }
        };

        historyDetailBackButton?.addEventListener('click', (event) => {
          event.preventDefault();
          resetHistoryDetail({ scrollTarget: historyRoot || scanHistorySection });
        });

        historyCompareElements.toggle?.addEventListener('click', (event) => {
          event.preventDefault();
          if (compareMode) {
            return;
          }
          enterCompareMode({ skipScroll: true });
          renderCompareControls();
        });

        historyCompareElements.cancel?.addEventListener('click', (event) => {
          event.preventDefault();
          resetCompareState({ skipScroll: true });
          renderCompareControls();
        });

        historyCompareElements.run?.addEventListener('click', (event) => {
          event.preventDefault();
          if (historyCompareElements.run?.disabled) {
            return;
          }
          openHistoryCompare();
        });

        historyCompareElements.close?.addEventListener('click', (event) => {
          event.preventDefault();
          resetCompareState({ skipScroll: true });
          renderCompareControls();
        });

        historyCompareElements.download?.addEventListener('click', (event) => {
          event.preventDefault();
          if (historyCompareElements.download?.disabled) {
            return;
          }
          downloadComparisonCsv();
        });

        runButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (typeof console !== 'undefined' && console.debug) {
            console.debug('[UI_START_SCAN_CLICK] Run Dedicated Scan clicked', {
              trackedPlaylistId: resolveTrackedPlaylistId(),
            });
          }
          setActiveSection('dedicated', { skipScroll: true, skipFetch: true });
          openBasicScanStage2();
          startScan({ source: 'button_click' });
        });

        basicScanStageController.openBasicScanStage1 = openBasicScanStage1;
        basicScanStageController.openBasicScanStage2 = openBasicScanStage2;

        const initializeScanSections = async () => {
          try {
            const activeScan = await fetchActiveScan();
            if (activeScan?.scan_id) {
              resumeActiveScan(activeScan);
              return;
            }
          } catch (error) {
            setStatus(normalizeErrorMessage(error, 'Failed to load scan status.'), 'status-error');
          }
          logSwitchLatest('none', 'no_active_scan');
          setStopButtonVisible(false);
          setActiveSection('insights', { skipScroll: true });
        };

        initializeScanSections();

        stopButton?.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          cancelActiveScan();
        });
      };

      setupBasicScan();
    </script>
  </body>
</html>
